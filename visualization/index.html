<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CityVoice - AI-Powered Citizen Suggestion Clustering | xAI Hackathon</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0c10;
            color: #e6edf3;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .graph-panel {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        #graph {
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        #graph:active {
            cursor: grabbing;
        }

        /* Subtle grid background */
        .graph-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image:
                linear-gradient(rgba(255,255,255,0.02) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.02) 1px, transparent 1px);
            background-size: 50px 50px;
            pointer-events: none;
        }

        /* Node glow effects */
        .node circle {
            filter: drop-shadow(0 0 2px currentColor);
            transition: all 0.3s ease;
        }

        .node:hover circle {
            filter: drop-shadow(0 0 6px currentColor);
            transform: scale(1.2);
        }

        /* Pulse animation for high-consensus clusters */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .side-panel {
            width: 400px;
            background: #0d1117;
            border-left: 1px solid #21262d;
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            padding: 24px 20px;
            border-bottom: 1px solid #21262d;
        }

        .logo-row {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo-icon {
            font-size: 1.5rem;
        }

        .panel-header h1 {
            font-size: 1.25rem;
            font-weight: 600;
            color: #f0f6fc;
            margin-bottom: 0;
            letter-spacing: -0.02em;
        }

        .panel-header p {
            font-size: 0.8rem;
            color: #7d8590;
            margin-top: 4px;
        }

        .powered-by {
            font-size: 0.65rem;
            color: #484f58;
            margin-top: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
        }

        .tabs {
            display: flex;
            border-bottom: 1px solid #21262d;
            background: rgba(13, 17, 23, 0.5);
        }

        .tab {
            flex: 1;
            padding: 12px 8px;
            text-align: center;
            cursor: pointer;
            background: transparent;
            border: none;
            color: #6e7681;
            font-size: 0.8rem;
            font-weight: 500;
            transition: all 0.2s;
            border-bottom: 2px solid transparent;
            margin-bottom: -1px;
        }

        .tab:hover {
            color: #c9d1d9;
        }

        .tab.active {
            color: #e07a5f;
            border-bottom-color: #e07a5f;
            background: transparent;
        }

        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }

        .cluster-card {
            background: #161b22;
            border-radius: 10px;
            padding: 14px 16px;
            margin-bottom: 10px;
            border: 1px solid #21262d;
            transition: all 0.2s;
            cursor: pointer;
        }

        .cluster-card:hover {
            background: #21262d;
            border-color: #30363d;
        }

        .cluster-card.selected {
            border-color: #e07a5f;
            box-shadow: 0 0 20px rgba(224, 122, 95, 0.15);
        }

        .cluster-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .cluster-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .cluster-title {
            font-weight: 600;
            font-size: 1rem;
        }

        .cluster-count {
            font-size: 0.75rem;
            color: #8b949e;
            background: #30363d;
            padding: 2px 8px;
            border-radius: 10px;
            margin-left: auto;
        }

        .cluster-summary {
            font-size: 0.85rem;
            color: #8b949e;
            line-height: 1.5;
            margin-bottom: 10px;
        }

        .consensus-badge {
            display: inline-block;
            font-size: 0.7rem;
            padding: 3px 8px;
            border-radius: 10px;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }

        .consensus-badge.high {
            background: rgba(34, 197, 94, 0.2);
            color: #22c55e;
            border: 1px solid rgba(34, 197, 94, 0.3);
        }

        .consensus-badge.medium {
            background: rgba(249, 115, 22, 0.2);
            color: #f97316;
            border: 1px solid rgba(249, 115, 22, 0.3);
        }

        .consensus-badge.low {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        .cluster-action {
            font-size: 0.8rem;
            color: #ffa657;
            padding: 8px;
            background: rgba(255, 166, 87, 0.1);
            border-radius: 6px;
            margin-bottom: 10px;
            border-left: 3px solid #ffa657;
        }

        .cluster-actions {
            margin: 10px 0;
        }

        .actions-label {
            font-size: 0.75rem;
            color: #8b949e;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .action-link {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            margin: 4px 0;
            background: rgba(88, 166, 255, 0.1);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            border-left: 2px solid #58a6ff;
        }

        .action-link:hover {
            background: rgba(88, 166, 255, 0.2);
            transform: translateX(2px);
        }

        .action-bullet {
            color: #58a6ff;
            font-weight: bold;
        }

        .action-title-text {
            flex: 1;
            font-size: 0.8rem;
            color: #c9d1d9;
        }

        .action-voices {
            font-size: 0.7rem;
            color: #8b949e;
            background: #21262d;
            padding: 2px 6px;
            border-radius: 10px;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .more-issues {
            font-size: 0.75rem;
            color: #8b949e;
            padding: 4px 8px;
            font-style: italic;
        }

        .actionable-item.highlighted {
            border: 2px solid #58a6ff;
            box-shadow: 0 0 20px rgba(88, 166, 255, 0.3);
        }

        .cluster-items {
            display: none;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #30363d;
        }

        .cluster-card.expanded .cluster-items {
            display: block;
        }

        .item-mini {
            font-size: 0.8rem;
            color: #8b949e;
            padding: 8px;
            background: #161b22;
            border-radius: 6px;
            margin-bottom: 6px;
        }

        .item-mini .username {
            color: #58a6ff;
            font-weight: 500;
        }

        .item-mini .username-link {
            color: #58a6ff;
            font-weight: 500;
            text-decoration: none;
        }

        .item-mini .username-link:hover {
            text-decoration: underline;
        }

        .node-detail {
            padding: 13px 12px 20px 12px;
        }

        .node-detail .summary {
            font-size: 1rem;
            line-height: 1.7;
            margin: 0 4px 14px 4px;
            color: #f0f6fc;
            padding: 16px;
            padding-right: 38px;
            background: #161b22;
            border-radius: 8px;
            text-align: left;
            position: relative;
            border-left: 3px solid #58a6ff;
        }

        .tweet-link-icon {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #6e7681;
            text-decoration: none;
            font-size: 0.8rem;
            padding: 4px 6px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .tweet-link-icon:hover {
            color: #58a6ff;
            background: rgba(88, 166, 255, 0.15);
        }

        .detail-meta {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
            padding: 0 14px 16px 14px;
            border-bottom: 1px solid #21262d;
        }

        .detail-author {
            font-size: 0.85rem;
            color: #58a6ff;
            font-weight: 500;
            text-decoration: none;
        }

        .detail-author:hover {
            text-decoration: underline;
        }

        .detail-date {
            font-size: 0.75rem;
            color: #6e7681;
        }

        .node-clusters {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 16px;
            padding-left: 4px;
        }

        .cluster-label-text {
            font-size: 0.7rem;
            color: #6e7681;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }

        .node-cluster-tag {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 5px 10px;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .node-cluster-tag:hover {
            transform: translateY(-1px);
            filter: brightness(1.1);
        }

        .node-cluster-tag .cluster-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .detail-actions {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .node-detail .connections-header {
            font-size: 0.7rem;
            color: #6e7681;
            margin-bottom: 14px;
            margin-top: 20px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            text-align: left;
            padding-left: 4px;
        }

        .connection-item {
            background: #161b22;
            padding: 12px 14px;
            border-radius: 8px;
            margin: 0 4px 16px 4px;
            border-left: 1px solid #e07a5f;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
        }

        .connection-item:hover {
            background: #21262d;
            border-left-width: 2px;
            transform: translateX(2px);
        }

        .connection-content {
            display: flex;
            align-items: flex-start;
            gap: 8px;
        }

        .connection-text-wrap {
            flex: 1;
            font-size: 0.85rem;
            line-height: 1.6;
            color: #c9d1d9;
        }

        .connection-item .reason {
            font-size: 0.75rem;
            color: #6e7681;
            font-style: italic;
            margin-top: 6px;
            padding-top: 6px;
            border-top: 1px solid #21262d;
        }

        .connection-item .connection-author {
            color: #58a6ff;
            font-weight: 500;
            text-decoration: none;
        }

        .connection-link-icon {
            color: #484f58;
            text-decoration: none;
            font-size: 0.75rem;
            padding: 2px;
            flex-shrink: 0;
        }

        .connection-link-icon:hover {
            color: #58a6ff;
        }

        .link-btn {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: transparent;
            color: #58a6ff;
            text-decoration: none;
            border-radius: 6px;
            font-size: 0.8rem;
            transition: all 0.2s;
            font-weight: 500;
            border: 1px solid #30363d;
        }

        .link-btn:hover {
            background: rgba(88, 166, 255, 0.1);
            border-color: #58a6ff;
        }

        .stats-bar {
            display: none;
            justify-content: space-around;
            padding: 16px 12px;
            background: linear-gradient(180deg, rgba(13, 17, 23, 0) 0%, rgba(13, 17, 23, 0.8) 100%);
            border-bottom: 1px solid #21262d;
        }

        .stat {
            text-align: center;
        }

        .stat-value {
            font-size: 1.4rem;
            font-weight: 700;
            color: #f0f6fc;
            font-family: 'JetBrains Mono', monospace;
        }

        .stat-label {
            font-size: 0.65rem;
            color: #6e7681;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 2px;
        }

        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 100;
        }

        .control-btn {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            border: 1px solid #30363d;
            background: rgba(33, 38, 45, 0.9);
            color: #8b949e;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.2s;
            backdrop-filter: blur(8px);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .control-btn:hover {
            background: rgba(48, 54, 61, 0.95);
            border-color: #484f58;
            color: #e6edf3;
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        .force-panel {
            position: absolute;
            top: 20px;
            left: 70px;
            background: rgba(22, 27, 34, 0.95);
            padding: 10px 16px;
            border-radius: 10px;
            border: 1px solid #30363d;
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 24px;
            backdrop-filter: blur(8px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .force-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .force-control label {
            font-size: 0.7rem;
            color: #8b949e;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            white-space: nowrap;
        }

        .force-control input[type="range"] {
            width: 80px;
            accent-color: #e07a5f;
            height: 4px;
        }

        .force-control span {
            font-size: 0.7rem;
            color: #6e7681;
            min-width: 40px;
            font-family: 'JetBrains Mono', monospace;
        }

        .legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(22, 27, 34, 0.95);
            padding: 12px 14px;
            border-radius: 10px;
            border: 1px solid #30363d;
            z-index: 100;
            backdrop-filter: blur(8px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .legend h4 {
            font-size: 0.65rem;
            color: #6e7681;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
            font-size: 0.8rem;
            cursor: pointer;
            padding: 5px 8px;
            border-radius: 6px;
            transition: all 0.2s;
            color: #c9d1d9;
        }

        .legend-item:hover {
            background: rgba(255, 123, 84, 0.1);
            color: #f0f6fc;
        }

        .legend-color {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .tooltip {
            position: absolute;
            background: rgba(22, 27, 34, 0.98);
            padding: 12px 16px;
            border-radius: 10px;
            border: 1px solid #30363d;
            font-size: 0.8rem;
            max-width: 320px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s;
            z-index: 1000;
            color: #c9d1d9;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            line-height: 1.5;
        }

        .tooltip.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .tooltip .username {
            color: #e07a5f;
            font-weight: 600;
            text-decoration: none;
        }

        .tooltip .username:hover {
            text-decoration: underline;
        }

        .tooltip .tweet-link {
            display: inline-block;
            margin-top: 8px;
            padding: 4px 10px;
            background: rgba(88, 166, 255, 0.15);
            color: #58a6ff;
            border-radius: 4px;
            font-size: 0.75rem;
            text-decoration: none;
            pointer-events: auto;
        }

        .tooltip .tweet-link:hover {
            background: rgba(88, 166, 255, 0.25);
        }

        /* Cluster overlay labels - Google Maps style */
        .cluster-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
            transition: opacity 0.3s ease;
            overflow: visible;
        }

        .cluster-label {
            position: absolute;
            transform: translate(-50%, -50%);
            background: rgba(13, 17, 23, 0.9);
            color: #f0f6fc;
            padding: 8px 14px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            white-space: nowrap;
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            pointer-events: auto;
            cursor: pointer;
            transition: all 0.2s ease;
            touch-action: none;
        }

        .cluster-label:hover {
            background: rgba(33, 38, 45, 0.98);
            transform: translate(-50%, -50%) scale(1.05);
            border-color: rgba(255, 255, 255, 0.25);
        }

        .cluster-label.hovered {
            background: rgba(224, 122, 95, 0.9);
            border-color: rgba(255, 255, 255, 0.4);
            transform: translate(-50%, -50%) scale(1.08);
        }

        /* Overview mode dimming effect */
        .graph-panel.overview-mode::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(10, 12, 16, 0.3);
            pointer-events: none;
            z-index: 40;
            transition: opacity 0.3s ease;
        }

        .cluster-label .count {
            display: inline-block;
            background: rgba(255, 255, 255, 0.15);
            padding: 2px 6px;
            border-radius: 8px;
            margin-left: 6px;
            font-size: 0.65rem;
            font-weight: 500;
        }

        .cluster-label .dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 6px;
            vertical-align: middle;
        }

        /* Overlay toggle control */
        .overlay-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(22, 27, 34, 0.95);
            padding: 6px;
            border-radius: 8px;
            border: 1px solid #30363d;
            z-index: 100;
            display: flex;
            gap: 2px;
            backdrop-filter: blur(8px);
        }

        .overlay-btn {
            padding: 6px 10px;
            border: none;
            background: transparent;
            color: #6e7681;
            font-size: 0.7rem;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .overlay-btn:hover {
            color: #c9d1d9;
        }

        .overlay-btn.active {
            background: #30363d;
            color: #f0f6fc;
        }

        .export-section {
            padding: 12px 16px;
            border-top: 1px solid #21262d;
            background: rgba(13, 17, 23, 0.5);
        }

        .export-btn {
            width: 100%;
            padding: 10px 16px;
            background: linear-gradient(135deg, #e07a5f 0%, #c96a50 100%);
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(224, 122, 95, 0.25);
        }

        .export-btn:hover {
            background: linear-gradient(135deg, #c96a50 0%, #b05a42 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(224, 122, 95, 0.35);
        }

        .export-btn:active {
            transform: translateY(0);
        }

        /* Project Selector Styles */
        .project-selector {
            border-bottom: 1px solid #21262d;
        }

        .project-selector-header {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 16px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .project-selector-header:hover {
            background: rgba(88, 166, 255, 0.1);
        }

        .project-toggle-icon {
            font-size: 0.7rem;
            color: #8b949e;
            transition: transform 0.2s;
        }

        .project-selector.expanded .project-toggle-icon {
            transform: rotate(90deg);
        }

        .project-current-name {
            flex: 1;
            font-size: 0.85rem;
            font-weight: 500;
            color: #e6edf3;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .project-switch-hint {
            font-size: 0.7rem;
            color: #58a6ff;
            opacity: 0.7;
        }

        .project-selector-content {
            display: none;
            padding: 0 12px 12px;
        }

        .project-selector.expanded .project-selector-content {
            display: block;
        }

        .project-list {
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 10px;
        }

        .project-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
            font-size: 0.8rem;
            color: #c9d1d9;
        }

        .project-item:hover {
            background: rgba(88, 166, 255, 0.15);
        }

        .project-item.active {
            background: rgba(88, 166, 255, 0.2);
            border-left: 2px solid #58a6ff;
        }

        .project-item-name {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .project-item-badge {
            font-size: 0.65rem;
            padding: 2px 6px;
            border-radius: 10px;
            background: #21262d;
            color: #8b949e;
        }

        .project-item-badge.has-clusters {
            background: rgba(35, 134, 54, 0.3);
            color: #3fb950;
        }

        .project-actions {
            display: flex;
            gap: 8px;
        }

        .project-new-btn, .project-cluster-btn {
            flex: 1;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid #30363d;
        }

        .project-new-btn {
            background: #21262d;
            color: #c9d1d9;
        }

        .project-new-btn:hover {
            background: #30363d;
            border-color: #58a6ff;
        }

        .project-cluster-btn {
            background: #238636;
            color: white;
            border-color: #238636;
        }

        .project-cluster-btn:hover {
            background: #2ea043;
        }

        .project-cluster-btn:disabled {
            background: #21262d;
            color: #8b949e;
            border-color: #30363d;
            cursor: not-allowed;
        }

        .search-box {
            padding: 12px 16px;
            border-bottom: 1px solid #21262d;
        }

        .search-input {
            width: 100%;
            padding: 10px 14px;
            border-radius: 8px;
            border: 1px solid #30363d;
            background: #161b22;
            color: #e6edf3;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        .search-input:focus {
            outline: none;
            border-color: #e07a5f;
            background: #21262d;
            box-shadow: 0 0 0 3px rgba(224, 122, 95, 0.1);
        }

        .search-input::placeholder {
            color: #6e7681;
        }

        .actionable-list {
            padding: 0;
        }

        .actionable-header {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #30363d;
        }

        .actionable-header h3 {
            font-size: 1rem;
            color: #e6edf3;
            margin-bottom: 4px;
        }

        .actionable-header p {
            font-size: 0.8rem;
            color: #8b949e;
        }

        .actionable-item {
            background: #21262d;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            border: 1px solid #30363d;
            display: flex;
            gap: 15px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .actionable-item:hover {
            background: #282e36;
            transform: translateX(5px);
        }

        .actionable-rank {
            font-size: 1.5rem;
            font-weight: 700;
            color: #484f58;
            min-width: 40px;
        }

        .actionable-content {
            flex: 1;
        }

        .actionable-title-row {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 8px;
        }

        .actionable-item h4 {
            font-size: 0.95rem;
            margin: 0;
            color: #e6edf3;
        }

        .topic-tag {
            font-size: 0.7rem;
            padding: 2px 8px;
            border-radius: 10px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .topic-tag:hover {
            transform: scale(1.05);
            filter: brightness(1.2);
        }

        .support-bar {
            height: 4px;
            background: #30363d;
            border-radius: 2px;
            margin-bottom: 6px;
            overflow: hidden;
        }

        .support-fill {
            height: 100%;
            border-radius: 2px;
            transition: width 0.5s ease-out;
        }

        .support-text {
            font-size: 0.75rem;
            color: #8b949e;
            margin-bottom: 8px;
        }

        .action-text {
            font-size: 0.85rem;
            color: #ffa657;
            margin-bottom: 8px;
            font-style: italic;
        }

        .proposal-text {
            font-size: 0.9rem;
            color: #c9d1d9;
            margin-bottom: 12px;
            line-height: 1.6;
            padding: 12px;
            background: #161b22;
            border-radius: 6px;
            border-left: 2px solid #58a6ff;
        }

        .supporting-demands {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            align-items: center;
            margin-top: 8px;
        }

        .demands-label {
            font-size: 0.75rem;
            color: #8b949e;
            margin-right: 4px;
        }

        .demand-chip {
            font-size: 0.7rem;
            padding: 3px 8px;
            background: #21262d;
            border: 1px solid #30363d;
            border-radius: 12px;
            color: #8b949e;
        }

        .demand-chip.clickable {
            cursor: pointer;
            transition: all 0.2s;
        }

        .demand-chip.clickable:hover {
            background: #30363d;
            border-color: #58a6ff;
            color: #58a6ff;
        }

        .actionable-toggle {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }

        .toggle-btn {
            padding: 6px 14px;
            border: 1px solid #30363d;
            background: #161b22;
            color: #8b949e;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s;
        }

        .toggle-btn:hover {
            background: #21262d;
            color: #c9d1d9;
        }

        .toggle-btn.active {
            background: #58a6ff;
            border-color: #58a6ff;
            color: #0d1117;
            font-weight: 500;
        }

        .demand-voices {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 8px;
        }

        .voice-link {
            font-size: 0.75rem;
            color: #58a6ff;
            text-decoration: none;
            padding: 2px 6px;
            background: rgba(88, 166, 255, 0.1);
            border-radius: 4px;
        }

        .voice-link:hover {
            background: rgba(88, 166, 255, 0.2);
            text-decoration: underline;
        }

        .demand-item {
            border-left: 3px solid #ffa657;
        }

        .tweets-toggle {
            font-size: 0.8rem;
            color: #58a6ff;
            cursor: pointer;
            margin-top: 10px;
            padding: 6px 0;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .tweets-toggle:hover {
            color: #79c0ff;
        }

        .toggle-icon {
            font-size: 0.7rem;
            transition: transform 0.2s;
        }

        .demand-item.tweets-expanded .toggle-icon {
            transform: rotate(90deg);
        }

        .demand-tweets {
            display: none;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #30363d;
        }

        .demand-item.tweets-expanded .demand-tweets {
            display: block;
        }

        .demand-tweet {
            background: #161b22;
            padding: 10px 12px;
            border-radius: 6px;
            margin-bottom: 8px;
            border-left: 2px solid #30363d;
        }

        .tweet-content {
            font-size: 0.85rem;
            color: #c9d1d9;
            line-height: 1.5;
            margin-bottom: 6px;
        }

        .tweet-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            font-size: 0.75rem;
        }

        .tweet-author {
            color: #58a6ff;
            text-decoration: none;
        }

        .tweet-author:hover {
            text-decoration: underline;
        }

        .tweet-date {
            color: #8b949e;
        }

        .tweet-link {
            color: #58a6ff;
            text-decoration: none;
            margin-left: auto;
        }

        .tweet-link:hover {
            text-decoration: underline;
        }

        .synthesized-action {
            border-left: 3px solid #58a6ff;
        }

        .actionable-item .description {
            font-size: 0.8rem;
            color: #8b949e;
            line-height: 1.5;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .grok-chat {
            height: 100%;
        }

        .grok-chat-card {
            display: flex;
            flex-direction: column;
            gap: 16px;
            height: 100%;
            padding: 18px;
            border-radius: 14px;
            background: #161b22;
            border: 1px solid #21262d;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
        }

        .grok-chat-controls {
            display: flex;
            justify-content: flex-end;
            padding-top: 8px;
        }

        .grok-clear-btn {
            border: 1px solid #2d333b;
            background: rgba(13, 17, 23, 0.6);
            color: #8b949e;
            border-radius: 8px;
            padding: 8px 16px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .grok-clear-btn:hover {
            color: #f0f6fc;
            border-color: #3d444d;
            background: rgba(22, 27, 34, 0.8);
        }

        .grok-quick-prompts {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .grok-quick-prompts button {
            border: 1px solid rgba(88, 166, 255, 0.3);
            background: rgba(88, 166, 255, 0.08);
            color: #9ecbff;
            border-radius: 999px;
            padding: 6px 12px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .grok-quick-prompts button:hover {
            background: rgba(88, 166, 255, 0.18);
            color: #cfe5ff;
        }

        .grok-chat-history {
            flex: 1;
            background: rgba(13, 17, 23, 0.95);
            border: 1px solid #21262d;
            border-radius: 12px;
            padding: 12px 14px;
            overflow-y: auto;
            min-height: 220px;
        }

        .grok-chat-hint {
            font-size: 0.8rem;
            color: #8b949e;
            text-align: center;
            padding: 10px;
        }

        .grok-chat-message {
            margin-bottom: 12px;
            padding: 10px 14px;
            border-radius: 14px;
            font-size: 0.85rem;
            line-height: 1.6;
            border: 1px solid #30363d;
            max-width: 92%;
        }

        .grok-chat-message.user {
            margin-left: auto;
            background: linear-gradient(135deg, rgba(88, 166, 255, 0.18), rgba(88, 166, 255, 0.05));
            border-color: rgba(88, 166, 255, 0.4);
        }

        .grok-chat-message.assistant {
            margin-right: auto;
            background: linear-gradient(135deg, rgba(224, 122, 95, 0.15), rgba(224, 122, 95, 0.04));
            border-color: rgba(224, 122, 95, 0.3);
        }

        .grok-chat-meta {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #8b949e;
            margin-bottom: 6px;
        }

        .grok-chat-text {
            color: #e6edf3;
            font-size: 0.85rem;
        }

        .grok-chat-text p {
            margin: 0 0 6px 0;
        }

        .grok-chat-form {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .grok-search-box {
            display: flex;
            align-items: center;
            gap: 12px;
            background: linear-gradient(135deg, rgba(22, 27, 34, 0.95), rgba(13, 17, 23, 0.98));
            border: 1px solid #30363d;
            border-radius: 16px;
            padding: 12px 16px;
            transition: all 0.2s ease;
        }

        .grok-search-box:focus-within {
            border-color: #e07a5f;
            box-shadow: 0 0 0 3px rgba(224, 122, 95, 0.15), 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .grok-search-icon {
            color: #8b949e;
            flex-shrink: 0;
            display: flex;
            align-items: center;
        }

        .grok-search-box textarea {
            flex: 1;
            border: none;
            background: transparent;
            color: #e6edf3;
            font-size: 0.95rem;
            resize: none;
            min-height: 24px;
            max-height: 120px;
            padding: 0;
            line-height: 1.5;
        }

        .grok-search-box textarea:focus {
            outline: none;
            box-shadow: none;
        }

        .grok-search-box textarea::placeholder {
            color: #6e7681;
        }

        .grok-search-btn {
            flex-shrink: 0;
            width: 40px;
            height: 40px;
            border-radius: 12px;
            border: none;
            background: linear-gradient(135deg, #e07a5f, #c96a52);
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .grok-search-btn:hover {
            background: linear-gradient(135deg, #e8907a, #e07a5f);
            transform: scale(1.05);
        }

        .grok-search-btn:active {
            transform: scale(0.98);
        }

        .grok-search-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .grok-spin {
            animation: grok-spin 1s linear infinite;
        }

        @keyframes grok-spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .grok-options {
            background: rgba(22, 27, 34, 0.6);
            border: 1px solid #21262d;
            border-radius: 10px;
            overflow: hidden;
        }

        .grok-options summary {
            padding: 10px 14px;
            cursor: pointer;
            font-size: 0.8rem;
            color: #8b949e;
            user-select: none;
            list-style: none;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .grok-options summary::before {
            content: '▸';
            transition: transform 0.2s ease;
        }

        .grok-options[open] summary::before {
            transform: rotate(90deg);
        }

        .grok-options summary::-webkit-details-marker {
            display: none;
        }

        .grok-options-content {
            padding: 12px 14px;
            padding-top: 0;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .grok-form-field {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .grok-form-field label {
            font-size: 0.7rem;
            color: #8b949e;
            text-transform: uppercase;
            letter-spacing: 0.4px;
        }

        .grok-chat-form textarea {
            width: 100%;
            border-radius: 10px;
            border: 1px solid #30363d;
            background: rgba(15, 18, 23, 0.95);
            color: #e6edf3;
            padding: 12px 14px;
            resize: vertical;
            min-height: 90px;
            font-size: 0.9rem;
        }

        .grok-chat-form textarea:focus {
            outline: none;
            border-color: #e07a5f;
            box-shadow: 0 0 0 3px rgba(224, 122, 95, 0.15);
        }

        .grok-form-row {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .grok-form-row > div {
            flex: 1 1 140px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .grok-input,
        .grok-select select {
            border-radius: 8px;
            border: 1px solid #30363d;
            background: rgba(13, 17, 23, 0.85);
            color: #e6edf3;
            padding: 8px 10px;
            font-size: 0.85rem;
            font-family: inherit;
        }

        .grok-input:focus,
        .grok-select select:focus {
            outline: none;
            border-color: #e07a5f;
            box-shadow: 0 0 0 2px rgba(224, 122, 95, 0.2);
        }

        .grok-select {
            position: relative;
        }

        .grok-select::after {
            content: '▾';
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: #8b949e;
            pointer-events: none;
            font-size: 0.8rem;
        }

        .grok-select select {
            appearance: none;
            width: 100%;
        }

        .grok-send-btn {
            border: none;
            border-radius: 10px;
            background: linear-gradient(135deg, #e07a5f 0%, #c96a50 100%);
            color: #fff;
            padding: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.2s, transform 0.2s;
        }

        .grok-send-btn.loading {
            position: relative;
        }

        .grok-send-btn.loading::after {
            content: '⌛';
            position: absolute;
            right: 16px;
            animation: pulse 1s infinite;
        }

        .grok-send-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .grok-status {
            font-size: 0.78rem;
            min-height: 18px;
            color: #8b949e;
        }

        .grok-status.success {
            color: #34d399;
        }

        .grok-status.error {
            color: #f87171;
        }

        .grok-status.loading {
            color: #facc15;
        }

        /* Manual import section */
        .grok-manual-section {
            margin-top: 20px;
            padding-top: 16px;
            border-top: 1px solid #3d4f61;
        }

        .grok-manual-header {
            font-size: 0.9rem;
            font-weight: 600;
            color: #e0e0e0;
            margin-bottom: 6px;
        }

        .grok-manual-description {
            font-size: 0.8rem;
            color: #9fb8d0;
            margin-bottom: 12px;
        }

        .grok-manual-buttons {
            display: flex;
            gap: 10px;
        }

        .grok-manual-btn, .grok-upload-btn {
            flex: 1;
            padding: 10px 12px;
            border-radius: 8px;
            font-size: 0.85rem;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
        }

        .grok-manual-btn {
            background: #2d3a4a;
            border: 1px solid #4a5d73;
            color: #e0e0e0;
        }

        .grok-manual-btn:hover {
            background: #3d4f61;
            border-color: #5a7d9a;
        }

        .grok-upload-btn {
            background: #1a4a2e;
            border: 1px solid #238636;
            color: #7ee787;
            display: inline-block;
        }

        .grok-upload-btn:hover {
            background: #238636;
            color: white;
        }

        /* Prompt Modal */
        .prompt-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .prompt-modal-content {
            background: #1e2a38;
            border-radius: 12px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        .prompt-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 1px solid #3d4f61;
        }

        .prompt-modal-header h3 {
            margin: 0;
            font-size: 1.1rem;
            color: #e0e0e0;
        }

        .prompt-modal-close {
            background: none;
            border: none;
            color: #9fb8d0;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }

        .prompt-modal-close:hover {
            color: #e0e0e0;
        }

        .prompt-modal-body {
            padding: 20px;
            overflow-y: auto;
        }

        .prompt-modal-body p {
            margin: 0 0 12px 0;
            font-size: 0.9rem;
            color: #9fb8d0;
        }

        .prompt-modal-body a {
            color: #7ee787;
        }

        .prompt-textarea {
            width: 100%;
            height: 250px;
            background: #151f2a;
            border: 1px solid #3d4f61;
            border-radius: 8px;
            color: #e0e0e0;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.8rem;
            padding: 12px;
            resize: none;
        }

        .prompt-modal-footer {
            display: flex;
            gap: 10px;
            padding: 16px 20px;
            border-top: 1px solid #3d4f61;
        }

        .prompt-copy-btn {
            flex: 1;
            padding: 10px 16px;
            background: #238636;
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background 0.2s;
        }

        .prompt-copy-btn:hover {
            background: #2ea043;
        }

        .prompt-close-btn {
            padding: 10px 16px;
            background: #3d4f61;
            border: none;
            border-radius: 8px;
            color: #e0e0e0;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background 0.2s;
        }

        .prompt-close-btn:hover {
            background: #4a5d73;
        }

        .grok-result {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .grok-result-meta {
            font-size: 0.8rem;
            color: #9fb8d0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .grok-save-csv-btn {
            background: #238636;
            color: white;
            border: none;
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: background 0.2s;
        }

        .grok-save-csv-btn:hover {
            background: #2ea043;
        }

        .grok-result-actions {
            display: flex;
            gap: 8px;
        }

        .grok-add-btn {
            background: #58a6ff;
            color: white;
            border: none;
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: background 0.2s;
        }

        .grok-add-btn:hover {
            background: #79c0ff;
        }

        .grok-row {
            border-radius: 10px;
            border: 1px solid #30363d;
            padding: 12px 14px;
            background: rgba(15, 18, 23, 0.9);
            margin-bottom: 8px;
        }

        .grok-row-header {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            color: #8b949e;
            margin-bottom: 6px;
            gap: 12px;
        }

        .grok-row-link {
            font-size: 0.75rem;
            display: inline-flex;
            gap: 6px;
            color: #58a6ff;
            text-decoration: none;
            margin-top: 6px;
            align-items: center;
        }

        .grok-row-link::after {
            content: '↗';
            font-size: 0.75rem;
        }

        .grok-row-link:hover {
            text-decoration: underline;
        }

        .grok-error {
            color: #ef4444;
        }

        .grok-raw {
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 10px;
            font-size: 0.75rem;
            overflow-x: auto;
        }

        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: #8b949e;
        }

        .empty-state p {
            font-size: 0.9rem;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #0d1117;
        }

        ::-webkit-scrollbar-thumb {
            background: #30363d;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #484f58;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="graph-panel">
            <svg id="graph"></svg>

            <div class="controls">
                <button class="control-btn" id="zoomIn" title="Zoom In">+</button>
                <button class="control-btn" id="zoomOut" title="Zoom Out">−</button>
                <button class="control-btn" id="resetView" title="Reset View">⌖</button>
            </div>

            <div class="force-panel" id="forcePanel">
                <div class="force-control">
                    <label>Repulsion</label>
                    <input type="range" id="chargeSlider" min="-3000" max="-200" value="-1500">
                    <span id="chargeValue">-1500</span>
                </div>
                <div class="force-control">
                    <label>Distance</label>
                    <input type="range" id="distanceSlider" min="50" max="400" value="200">
                    <span id="distanceValue">200</span>
                </div>
                <div class="force-control">
                    <label>Collision</label>
                    <input type="range" id="collisionSlider" min="50" max="200" value="120">
                    <span id="collisionValue">120</span>
                </div>
            </div>

            <div class="legend" id="legend">
                <h4>Topics</h4>
            </div>

            <div class="cluster-overlay" id="clusterOverlay"></div>

            <div class="overlay-toggle" id="overlayToggle">
                <button class="overlay-btn active" data-mode="auto">Auto</button>
                <button class="overlay-btn" data-mode="always">Always</button>
                <button class="overlay-btn" data-mode="never">Never</button>
            </div>

            <div class="tooltip" id="tooltip"></div>
        </div>

        <div class="side-panel">
            <div class="panel-header">
                <div class="logo-row">
                    <span class="logo-icon">🏙️</span>
                    <h1>CityVoice</h1>
                </div>
                <p>AI-powered citizen suggestion clustering</p>
                <div class="powered-by">Powered by xAI Grok</div>
            </div>

            <div class="stats-bar">
                <div class="stat">
                    <div class="stat-value" id="totalIdeas">0</div>
                    <div class="stat-label">Ideas</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="totalConnections">0</div>
                    <div class="stat-label">Connections</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="totalClusters">0</div>
                    <div class="stat-label">Clusters</div>
                </div>
            </div>

            <!-- Project Selector (Collapsible) -->
            <div class="project-selector">
                <div class="project-selector-header" onclick="toggleProjectSelector()">
                    <span class="project-toggle-icon">▶</span>
                    <span class="project-current-name" id="currentProjectName">NYC Urbanist Ideas</span>
                    <span class="project-switch-hint">Switch</span>
                </div>
                <div class="project-selector-content" id="projectSelectorContent">
                    <div class="project-list" id="projectList">
                        <!-- Projects loaded dynamically -->
                    </div>
                    <div class="project-actions">
                        <button class="project-new-btn" onclick="showNewProjectDialog()">+ New Project</button>
                        <button class="project-cluster-btn" id="runClusteringBtn" onclick="runCurrentProjectClustering()">Run Clustering</button>
                    </div>
                </div>
            </div>

            <div class="search-box">
                <input type="text" class="search-input" id="searchInput" placeholder="Search ideas...">
            </div>

            <div class="tabs">
                <button class="tab active" data-tab="clusters">Clusters</button>
                <button class="tab" data-tab="actionable">Actionable</button>
                <button class="tab" data-tab="detail">Detail</button>
                <button class="tab" data-tab="grok">Grok Search</button>
            </div>

            <div class="panel-content">
                <div class="tab-content active" id="clusters-tab">
                    <div id="clusterList"></div>
                </div>

                <div class="tab-content" id="actionable-tab">
                    <div id="actionableList" class="actionable-list"></div>
                </div>

                <div class="tab-content" id="grok-tab">
                    <div class="grok-chat">
                        <div class="grok-chat-card">
                            <form class="grok-chat-form" id="grokChatForm">
                                <div class="grok-search-box">
                                    <div class="grok-search-icon">
                                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                            <circle cx="11" cy="11" r="8"></circle>
                                            <path d="m21 21-4.35-4.35"></path>
                                        </svg>
                                    </div>
                                    <textarea id="grokPrompt" placeholder="Search X for civic planning ideas..." required></textarea>
                                    <button type="submit" class="grok-search-btn" id="grokSendBtn">
                                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                            <path d="M5 12h14M12 5l7 7-7 7"/>
                                        </svg>
                                    </button>
                                </div>
                            </form>

                            <div class="grok-quick-prompts">
                                <button type="button" data-grok-prompt="Recent bus lane wins in Queens" data-grok-count="8">Bus lanes in Queens</button>
                                <button type="button" data-grok-prompt="Protected bike lane proposals near Brooklyn schools" data-grok-count="10">Bike safety near schools</button>
                                <button type="button" data-grok-prompt="Community feedback on sidewalk dining in Manhattan" data-grok-count="6">Sidewalk dining</button>
                                <button type="button" data-grok-prompt="Flood mitigation or green infrastructure ideas for Staten Island" data-grok-count="8">Flood mitigation</button>
                            </div>

                            <details class="grok-options">
                                <summary>Options</summary>
                                <div class="grok-options-content">
                                    <div class="grok-form-row">
                                        <div>
                                            <label for="grokCount">Posts</label>
                                            <input class="grok-input" type="number" id="grokCount" min="1" max="25" value="10">
                                        </div>
                                        <div>
                                            <label for="grokModel">Model</label>
                                            <div class="grok-select">
                                                <select id="grokModel">
                                                    <option value="grok-4-1-fast">grok-4-1-fast</option>
                                                    <option value="grok-4-1">grok-4-1</option>
                                                </select>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="grok-form-row">
                                        <div>
                                            <label for="grokAllowed">Include handles</label>
                                            <input class="grok-input" type="text" id="grokAllowed" placeholder="Optional, comma-separated">
                                        </div>
                                        <div>
                                            <label for="grokExcluded">Exclude handles</label>
                                            <input class="grok-input" type="text" id="grokExcluded" placeholder="Optional, comma-separated">
                                        </div>
                                    </div>
                                </div>
                            </details>

                            <div class="grok-chat-history" id="grokChatHistory">
                                <div class="grok-chat-hint">
                                    Search X for emerging urbanist ideas. Try a quick prompt above or enter your own search.
                                </div>
                            </div>

                            <div class="grok-chat-controls">
                                <button type="button" class="grok-clear-btn" id="grokClearBtn">Clear Results</button>
                            </div>

                            <div class="grok-status" id="grokStatus"></div>

                            <div class="grok-manual-section">
                                <div class="grok-manual-header">Manual Import</div>
                                <div class="grok-manual-description">
                                    If the API isn't working, use Grok directly and export to CSV.
                                </div>
                                <div class="grok-manual-buttons">
                                    <button type="button" class="grok-manual-btn" onclick="showPromptModal()">
                                        📋 Copy Prompt for Grok
                                    </button>
                                    <label class="grok-upload-btn">
                                        📁 Upload CSV
                                        <input type="file" id="csvUpload" accept=".csv" onchange="handleCSVUpload(event)" style="display: none;">
                                    </label>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="tab-content" id="detail-tab">
                    <div id="nodeDetail" class="empty-state">
                        <p>Click on a node in the graph to see details</p>
                    </div>
                </div>
            </div>

            <div class="export-section">
                <button class="export-btn" id="exportBtn">Export Consolidated Report</button>
            </div>
        </div>
    </div>

    <script>
        // Graph data will be loaded from JSON
        let graphData = null;
        let enhancedClusters = null;
        let clusters = [];
        let simulation = null;
        let showLabels = true;
        let selectedCluster = null;
        let selectedNode = null;

        // Color palette for clusters - muted, sophisticated tones
        const clusterColors = {
            'Housing': '#e07a5f',      // Terracotta
            'Transit': '#81b29a',      // Sage
            'Sidewalks': '#7c98b3',    // Steel blue
            'Safety': '#c97c5d',       // Rust
            'Green Space': '#a8c686',  // Olive
            'Schools': '#b8a9c9',      // Dusty lavender
            'Other': '#8b949e'         // Gray
        };

        const fallbackColors = [
            '#e07a5f', '#81b29a', '#7c98b3', '#c97c5d', '#a8c686',
            '#b8a9c9', '#9ab3d5', '#d4a574', '#a3c4bc', '#c9b1d4'
        ];

        // Node dimension constants
        const NODE_FONT_SIZE = 11;
        const NODE_LINE_HEIGHT = 14;
        const NODE_PADDING_V = 8;
        const NODE_PADDING_H = 10;

        // Overlay mode: 'auto' | 'always' | 'never'
        let overlayMode = 'auto';

        // Tooltip hover state
        let tooltipTimeout = null;
        let isTooltipHovered = false;

        // Project management
        let currentProject = 'default';
        let projectsList = [];

        // Project selector functions
        function toggleProjectSelector() {
            const selector = document.querySelector('.project-selector');
            selector.classList.toggle('expanded');
            if (selector.classList.contains('expanded')) {
                loadProjectsList();
            }
        }

        async function loadProjectsList() {
            try {
                const response = await fetch('/api/projects');
                const data = await response.json();
                projectsList = data.projects || [];
                renderProjectsList();
            } catch (error) {
                console.error('Failed to load projects:', error);
            }
        }

        function renderProjectsList() {
            const container = document.getElementById('projectList');
            if (!container) return;

            container.innerHTML = projectsList.map(project => `
                <div class="project-item ${project.name === currentProject ? 'active' : ''}"
                     onclick="switchProject('${project.name}')">
                    <span class="project-item-name">${project.display_name}</span>
                    ${project.has_clusters ? '<span class="project-item-badge has-clusters">Clustered</span>' : ''}
                    ${project.is_default ? '<span class="project-item-badge">Default</span>' : ''}
                </div>
            `).join('');
        }

        async function switchProject(projectName) {
            if (projectName === currentProject) return;

            try {
                const response = await fetch(`/api/projects/${projectName}`);
                if (!response.ok) throw new Error('Failed to load project');

                const data = await response.json();
                currentProject = projectName;

                // Update graph data
                graphData = data.connections;
                enhancedClusters = data.clusters;

                // Update UI
                const projectInfo = projectsList.find(p => p.name === projectName);
                document.getElementById('currentProjectName').textContent =
                    projectInfo ? projectInfo.display_name : projectName;

                // Re-render graph
                initGraph();
                renderProjectsList();

                // Collapse selector
                document.querySelector('.project-selector').classList.remove('expanded');

            } catch (error) {
                console.error('Failed to switch project:', error);
                alert('Failed to load project: ' + error.message);
            }
        }

        function showNewProjectDialog() {
            const name = prompt('Enter a name for the new project:');
            if (name && name.trim()) {
                createProject(name.trim());
            }
        }

        async function createProject(name) {
            try {
                const response = await fetch('/api/projects', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name })
                });

                if (!response.ok) {
                    const data = await response.json();
                    throw new Error(data.error || 'Failed to create project');
                }

                const data = await response.json();
                await loadProjectsList();
                switchProject(data.name);

            } catch (error) {
                console.error('Failed to create project:', error);
                alert('Failed to create project: ' + error.message);
            }
        }

        async function runCurrentProjectClustering() {
            const btn = document.getElementById('runClusteringBtn');
            if (!btn) return;

            const originalText = btn.textContent;
            btn.disabled = true;
            btn.textContent = 'Running...';

            try {
                const response = await fetch(`/api/projects/${currentProject}/cluster`, {
                    method: 'POST'
                });

                if (!response.ok) {
                    const data = await response.json();
                    throw new Error(data.error || 'Clustering failed');
                }

                // Reload the project to get updated clusters
                await switchProject(currentProject);
                await loadProjectsList();
                alert('Clustering completed successfully!');

            } catch (error) {
                console.error('Clustering failed:', error);
                alert('Clustering failed: ' + error.message);
            } finally {
                btn.disabled = false;
                btn.textContent = originalText;
            }
        }

        async function addGrokResultsToProject(rows) {
            if (!rows || rows.length === 0) {
                alert('No results to add');
                return;
            }

            try {
                const response = await fetch(`/api/projects/${currentProject}/nodes`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ rows })
                });

                if (!response.ok) {
                    const data = await response.json();
                    throw new Error(data.error || 'Failed to add nodes');
                }

                const data = await response.json();
                alert(`Added ${data.added} nodes to the graph. Total: ${data.total} nodes.`);

                // Reload the project
                await switchProject(currentProject);

            } catch (error) {
                console.error('Failed to add nodes:', error);
                alert('Failed to add nodes: ' + error.message);
            }
        }

        // Topic keywords for classification
        const topicKeywords = {
            'Housing': ['housing', 'home', 'apartment', 'ADU', 'dwelling', 'zoning', 'residential', 'units', 'building', 'dense', 'homes'],
            'Transit': ['bus', 'subway', 'transit', 'rail', 'train', 'metro', 'transport', 'commute', 'lane'],
            'Sidewalks': ['sidewalk', 'pedestrian', 'street', 'walk', 'crosswalk', 'curb', 'wider'],
            'Safety': ['safety', 'safe', 'police', 'officer', 'crime', 'security', 'enforcement', 'cops'],
            'Green Space': ['green', 'tree', 'park', 'garden', 'nature', 'permeable', 'flood'],
            'Bike Infrastructure': ['bike', 'bicycle', 'cycling'],
            'Schools': ['school', 'student', 'children', 'kids']
        };

        // Load and process data
        async function loadData() {
            try {
                // Load both data files in parallel
                const [graphResponse, clustersResponse] = await Promise.all([
                    fetch('/data/connections.json'),
                    fetch('/data/enhanced_clusters.json').catch(() => null)
                ]);

                graphData = await graphResponse.json();

                // Try to load enhanced clusters
                if (clustersResponse && clustersResponse.ok) {
                    enhancedClusters = await clustersResponse.json();
                    console.log('Loaded enhanced clusters:', enhancedClusters);
                }

                // Classify nodes by topic
                graphData.nodes.forEach(node => {
                    node.topics = classifyNode(node);
                    node.primaryTopic = node.topics[0] || 'Other';
                });

                // Use enhanced clusters if available, otherwise detect them
                if (enhancedClusters) {
                    useEnhancedClusters();
                } else {
                    detectClusters();
                }

                // Initialize visualization
                initGraph();
                updateStats();
                renderClusters();
                renderActionable();
                setupLegend();
                setupClusterOverlay();
                hookClusterLabelUpdates();
                setupOverlayToggle();

            } catch (error) {
                console.error('Error loading data:', error);
            }
        }

        function useEnhancedClusters() {
            // Build cluster assignments from enhanced clusters
            const nodeToCluster = new Map();
            let colorIdx = 0;

            clusters = enhancedClusters.clusters.map(ec => {
                const color = clusterColors[ec.topic] || fallbackColors[colorIdx++ % fallbackColors.length];

                ec.nodes.forEach(n => {
                    nodeToCluster.set(n.id, {
                        clusterId: ec.id,
                        color: color
                    });
                });

                return {
                    id: ec.id,
                    name: ec.name,
                    topic: ec.topic,
                    color: color,
                    nodes: ec.nodes.map(n => graphData.nodes.find(gn => gn.id === n.id) || n),
                    summary: ec.summary,
                    action: ec.action,
                    consensus: ec.consensus,
                    demands: ec.demands || [],
                    synthesized_actions: ec.synthesized_actions || []
                };
            });

            // Assign cluster info to nodes
            graphData.nodes.forEach(node => {
                const info = nodeToCluster.get(node.id);
                if (info) {
                    node.cluster = info.clusterId;
                    node.clusterColor = info.color;
                } else {
                    node.cluster = -1;
                    node.clusterColor = '#6b7280';
                }
            });
        }

        function classifyNode(node) {
            const text = (node.summary || '').toLowerCase();
            const topics = [];

            for (const [topic, keywords] of Object.entries(topicKeywords)) {
                if (keywords.some(kw => text.includes(kw))) {
                    topics.push(topic);
                }
            }

            return topics.length > 0 ? topics : ['Other'];
        }

        // Simple community detection using connected components and edge density
        function detectClusters() {
            const nodes = graphData.nodes;
            const edges = graphData.edges;

            // Build adjacency map with weights (connection count)
            const adjacency = new Map();
            nodes.forEach(n => adjacency.set(n.id, new Set()));

            edges.forEach(e => {
                adjacency.get(e.source_id).add(e.target_id);
                adjacency.get(e.target_id).add(e.source_id);
            });

            // Group by primary topic first, then subdivide by connectivity
            const topicGroups = new Map();
            nodes.forEach(node => {
                const topic = node.primaryTopic;
                if (!topicGroups.has(topic)) {
                    topicGroups.set(topic, []);
                }
                topicGroups.get(topic).push(node);
            });

            let clusterIndex = 0;
            clusters = [];

            topicGroups.forEach((topicNodes, topic) => {
                // For each topic group, find sub-clusters based on connectivity
                const subClusters = findSubClusters(topicNodes, adjacency);

                subClusters.forEach(subCluster => {
                    const color = clusterColors[clusterIndex % clusterColors.length];
                    const clusterObj = {
                        id: clusterIndex,
                        name: generateClusterName(subCluster, topic),
                        topic: topic,
                        color: color,
                        nodes: subCluster,
                        summary: generateClusterSummary(subCluster)
                    };

                    subCluster.forEach(node => {
                        node.cluster = clusterIndex;
                        node.clusterColor = color;
                    });

                    clusters.push(clusterObj);
                    clusterIndex++;
                });
            });
        }

        function findSubClusters(topicNodes, adjacency) {
            if (topicNodes.length <= 2) {
                return [topicNodes];
            }

            // Simple greedy clustering: group nodes that share edges
            const visited = new Set();
            const subClusters = [];

            topicNodes.forEach(node => {
                if (visited.has(node.id)) return;

                const cluster = [node];
                visited.add(node.id);

                const neighbors = adjacency.get(node.id);
                topicNodes.forEach(other => {
                    if (!visited.has(other.id) && neighbors.has(other.id)) {
                        cluster.push(other);
                        visited.add(other.id);
                    }
                });

                subClusters.push(cluster);
            });

            // Merge small clusters
            const merged = [];
            let currentMerge = [];

            subClusters.forEach(cluster => {
                if (cluster.length >= 2) {
                    merged.push(cluster);
                } else {
                    currentMerge = currentMerge.concat(cluster);
                    if (currentMerge.length >= 2) {
                        merged.push(currentMerge);
                        currentMerge = [];
                    }
                }
            });

            if (currentMerge.length > 0) {
                if (merged.length > 0) {
                    merged[merged.length - 1] = merged[merged.length - 1].concat(currentMerge);
                } else {
                    merged.push(currentMerge);
                }
            }

            return merged.length > 0 ? merged : [topicNodes];
        }

        function generateClusterName(nodes, topic) {
            // Extract key themes from summaries
            const allText = nodes.map(n => n.summary || '').join(' ').toLowerCase();

            // Find specific sub-themes
            if (allText.includes('staten island')) return `Staten Island ${topic}`;
            if (allText.includes('school')) return `School ${topic}`;
            if (allText.includes('wider') || allText.includes('width')) return `Sidewalk Width Reform`;
            if (allText.includes('bus lane')) return `Bus Lane Expansion`;
            if (allText.includes('dense') || allText.includes('density')) return `Dense Development`;
            if (allText.includes('pedestrian')) return `Pedestrianization`;

            return topic;
        }

        function generateClusterSummary(nodes) {
            // Create consolidated summary from node summaries
            const ideas = nodes.map(n => n.summary).filter(s => s && s.length > 10);
            if (ideas.length === 0) return 'Various related suggestions';

            if (ideas.length === 1) return ideas[0];

            // Find common themes
            return `${nodes.length} related suggestions: ${ideas[0].substring(0, 100)}...`;
        }

        function initGraph() {
            const svg = d3.select('#graph');

            // Clear existing graph elements when switching projects
            svg.selectAll('*').remove();

            const container = svg.node().parentElement;
            const width = container.clientWidth;
            const height = container.clientHeight;

            svg.attr('viewBox', [0, 0, width, height]);

            // Handle empty project
            if (!graphData || !graphData.nodes || graphData.nodes.length === 0) {
                const g = svg.append('g').attr('class', 'graph-container');
                g.append('text')
                    .attr('x', width / 2)
                    .attr('y', height / 2)
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#666')
                    .attr('font-size', '16px')
                    .text('No data yet. Use Grok Search to add nodes.');

                // Clear sidebar clusters
                const clusterList = document.getElementById('clusterList');
                if (clusterList) {
                    clusterList.innerHTML = '<div style="color: #666; padding: 20px; text-align: center;">No clusters yet. Add data and run clustering.</div>';
                }

                // Clear topics legend
                const topicLegend = document.querySelector('.topic-legend');
                if (topicLegend) topicLegend.innerHTML = '';

                return;
            }

            // Create container for zoom
            const g = svg.append('g').attr('class', 'graph-container');

            // Setup zoom
            const zoom = d3.zoom()
                .scaleExtent([0.2, 4])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                    // Update cluster overlay labels on zoom
                    if (typeof updateClusterLabelPositions === 'function') {
                        updateClusterLabelPositions();
                    }
                });

            svg.call(zoom);

            // Store zoom for global access
            window.svgZoom = zoom;
            window.svgElement = svg;
            window.graphContainer = g;
            window.graphWidth = width;
            window.graphHeight = height;

            // Setup controls
            d3.select('#zoomIn').on('click', () => svg.transition().call(zoom.scaleBy, 1.3));
            d3.select('#zoomOut').on('click', () => svg.transition().call(zoom.scaleBy, 0.7));
            d3.select('#resetView').on('click', () => svg.transition().call(zoom.transform, d3.zoomIdentity));

            // Force control sliders
            document.getElementById('chargeSlider').addEventListener('input', (e) => {
                forceParams.charge = parseInt(e.target.value);
                document.getElementById('chargeValue').textContent = e.target.value;
                window.updateForces();
            });
            document.getElementById('distanceSlider').addEventListener('input', (e) => {
                forceParams.linkDistance = parseInt(e.target.value);
                document.getElementById('distanceValue').textContent = e.target.value;
                window.updateForces();
            });
            document.getElementById('collisionSlider').addEventListener('input', (e) => {
                forceParams.collisionRadius = parseInt(e.target.value);
                document.getElementById('collisionValue').textContent = e.target.value;
                window.updateForces();
            });

            // Prepare edge data with node references
            const nodeMap = new Map(graphData.nodes.map(n => [n.id, n]));
            const links = graphData.edges.map(e => ({
                source: nodeMap.get(e.source_id),
                target: nodeMap.get(e.target_id),
                reason: e.reason
            }));

            // Force parameters (adjustable)
            let forceParams = {
                charge: -1500,
                linkDistance: 200,
                linkStrength: 0.2,
                collisionRadius: 120
            };

            // Create force simulation
            simulation = d3.forceSimulation(graphData.nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(forceParams.linkDistance).strength(forceParams.linkStrength))
                .force('charge', d3.forceManyBody().strength(forceParams.charge))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(forceParams.collisionRadius));

            // Store for later access
            window.simulation = simulation;
            window.forceParams = forceParams;
            window.updateForces = function() {
                simulation
                    .force('charge', d3.forceManyBody().strength(forceParams.charge))
                    .force('link').distance(forceParams.linkDistance).strength(forceParams.linkStrength);
                simulation.force('collision').radius(forceParams.collisionRadius);
                simulation.alpha(0.5).restart();
            };

            // Draw edges
            const link = g.append('g')
                .attr('class', 'links')
                .selectAll('line')
                .data(links)
                .enter().append('line')
                .attr('stroke', '#4a5568')
                .attr('stroke-opacity', 0.6)
                .attr('stroke-width', 1.5);

            // Draw nodes
            const node = g.append('g')
                .attr('class', 'nodes')
                .selectAll('g')
                .data(graphData.nodes)
                .enter().append('g')
                .attr('class', 'node')
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));

            // Node labels - show summary text, truncated
            // Using global constants: NODE_FONT_SIZE, NODE_LINE_HEIGHT, NODE_PADDING_V, NODE_PADDING_H
            const fontSize = NODE_FONT_SIZE;
            const lineHeight = NODE_LINE_HEIGHT;
            const paddingV = NODE_PADDING_V;
            const paddingH = NODE_PADDING_H;

            const nodeText = node.append('text')
                .attr('class', 'node-label')
                .attr('x', paddingH)
                .attr('fill', '#e6edf3')
                .attr('font-size', `${fontSize}px`)
                .style('pointer-events', 'none')
                .each(function(d) {
                    const text = d3.select(this);
                    const summary = d.summary || 'No summary';
                    const maxChars = 30;

                    // Split into lines
                    const words = summary.split(' ');
                    let lines = [];
                    let currentLine = '';

                    words.forEach(word => {
                        if ((currentLine + ' ' + word).trim().length <= maxChars) {
                            currentLine = (currentLine + ' ' + word).trim();
                        } else {
                            if (currentLine) lines.push(currentLine);
                            currentLine = word;
                        }
                    });
                    if (currentLine) lines.push(currentLine);

                    // Limit to 3 lines, add ellipsis if needed
                    if (lines.length > 3) {
                        lines = lines.slice(0, 3);
                        lines[2] = lines[2].substring(0, 26) + '...';
                    }

                    d.lineCount = lines.length;
                    d.maxLineWidth = Math.max(...lines.map(l => l.length)) * 6.5;

                    // Calculate centered y position
                    // Box height: paddingV + (lineCount * lineHeight) + paddingV - (lineHeight - fontSize)
                    // First baseline should be at: paddingV + fontSize (roughly)
                    const boxHeight = paddingV * 2 + d.lineCount * lineHeight - (lineHeight - fontSize);
                    const firstLineY = paddingV + fontSize - 2; // -2 for visual baseline adjustment

                    text.attr('y', firstLineY);

                    lines.forEach((line, i) => {
                        text.append('tspan')
                            .attr('x', paddingH)
                            .attr('dy', i === 0 ? 0 : lineHeight)
                            .text(line);
                    });
                });

            // Add rounded rectangle background behind text
            const getNodeHeight = (d) => paddingV * 2 + (d.lineCount || 2) * lineHeight - (lineHeight - fontSize);

            const getNodeWidth = (d) => Math.max(d.maxLineWidth + paddingH * 2, 120);

            node.insert('rect', 'text')
                .attr('class', 'node-bg')
                .attr('rx', 6)
                .attr('ry', 6)
                .attr('fill', '#21262d')
                .attr('stroke', d => d.clusterColor || '#81b29a')
                .attr('stroke-width', 1)
                .attr('fill-opacity', 1)
                .attr('stroke-opacity', 1)
                .attr('width', d => getNodeWidth(d))
                .attr('height', d => getNodeHeight(d))
                .attr('x', 0)
                .attr('y', 0)
                .style('cursor', 'pointer')
                .on('mouseover', handleMouseOver)
                .on('mouseout', handleMouseOut)
                .on('click', handleNodeClick);

            // Update positions on tick - edges connect to center of nodes
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x + getNodeWidth(d.source) / 2)
                    .attr('y1', d => d.source.y + getNodeHeight(d.source) / 2)
                    .attr('x2', d => d.target.x + getNodeWidth(d.target) / 2)
                    .attr('y2', d => d.target.y + getNodeHeight(d.target) / 2);

                node.attr('transform', d => `translate(${d.x},${d.y})`);
            });

            function adjacencyCount(id) {
                return graphData.edges.filter(e => e.source_id === id || e.target_id === id).length;
            }

            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
        }

        // Node dimension helpers
        function calcNodeWidth(n) {
            return Math.max((n.maxLineWidth || 100) + NODE_PADDING_H * 2, 120);
        }

        function calcNodeHeight(n) {
            return NODE_PADDING_V * 2 + (n.lineCount || 2) * NODE_LINE_HEIGHT - (NODE_LINE_HEIGHT - NODE_FONT_SIZE);
        }

        // Pan and zoom to show specific nodes
        function panToNodes(nodeIds, padding = 100) {
            if (!window.svgZoom || !nodeIds || nodeIds.length === 0) return;

            const targetNodes = graphData.nodes.filter(n => nodeIds.includes(n.id));
            if (targetNodes.length === 0) return;

            // Calculate bounding box of target nodes
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            targetNodes.forEach(n => {
                const nodeWidth = calcNodeWidth(n);
                const nodeHeight = calcNodeHeight(n);
                minX = Math.min(minX, n.x);
                maxX = Math.max(maxX, n.x + nodeWidth);
                minY = Math.min(minY, n.y);
                maxY = Math.max(maxY, n.y + nodeHeight);
            });

            // Add padding
            minX -= padding;
            maxX += padding;
            minY -= padding;
            maxY += padding;

            // Calculate zoom and translation
            const boxWidth = maxX - minX;
            const boxHeight = maxY - minY;
            const scale = Math.min(
                window.graphWidth / boxWidth,
                window.graphHeight / boxHeight,
                2 // Max zoom
            ) * 0.9;

            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;

            const transform = d3.zoomIdentity
                .translate(window.graphWidth / 2, window.graphHeight / 2)
                .scale(scale)
                .translate(-centerX, -centerY);

            window.svgElement
                .transition()
                .duration(750)
                .ease(d3.easeCubicInOut)
                .call(window.svgZoom.transform, transform);
        }

        // Pan to a single node
        function panToNode(nodeId) {
            panToNodes([nodeId], 200);
        }

        function handleMouseOver(event, d) {
            // Clear any pending hide timeout
            if (tooltipTimeout) clearTimeout(tooltipTimeout);

            const tooltip = d3.select('#tooltip');
            const hasLink = d.link && d.link.startsWith('http');
            const handle = d.username.replace('@', '');
            tooltip
                .html(`
                    <div style="margin-bottom: 8px; line-height: 1.4;">${d.summary || 'No summary'}</div>
                    <a href="https://twitter.com/${handle}" target="_blank" class="username" onclick="event.stopPropagation();">${d.username}</a> · ${d.date || ''}
                    ${hasLink ? `<br><a href="${d.link}" target="_blank" class="tweet-link" onclick="event.stopPropagation();">View Tweet →</a>` : ''}
                `)
                .style('left', (event.pageX + 15) + 'px')
                .style('top', (event.pageY - 10) + 'px')
                .classed('visible', true);

            // Highlight connected nodes
            const connected = new Set();
            graphData.edges.forEach(e => {
                if (e.source_id === d.id) connected.add(e.target_id);
                if (e.target_id === d.id) connected.add(e.source_id);
            });

            d3.selectAll('.node-bg')
                .attr('stroke-width', n => n.id === d.id || connected.has(n.id) ? 2 : 1)
                .attr('opacity', n => n.id === d.id || connected.has(n.id) ? 1 : 0.4);
            d3.selectAll('.node-label')
                .attr('opacity', n => n.id === d.id || connected.has(n.id) ? 1 : 0.3);

            d3.selectAll('.links line')
                .attr('stroke', l =>
                    (l.source.id === d.id || l.target.id === d.id) ? '#e07a5f' : '#4a5568'
                )
                .attr('stroke-opacity', l =>
                    (l.source.id === d.id || l.target.id === d.id) ? 1 : 0.2
                )
                .attr('stroke-width', l =>
                    (l.source.id === d.id || l.target.id === d.id) ? 2 : 1
                );
        }

        function handleMouseOut() {
            // Delay hiding tooltip to allow clicking link
            tooltipTimeout = setTimeout(() => {
                if (!isTooltipHovered) {
                    d3.select('#tooltip').classed('visible', false);
                    d3.selectAll('.node-bg')
                        .attr('stroke-width', 1)
                        .attr('opacity', 1);
                    d3.selectAll('.node-label').attr('opacity', 1);
                    d3.selectAll('.links line')
                        .attr('stroke', '#4a5568')
                        .attr('stroke-opacity', 0.6)
                        .attr('stroke-width', 1.5);
                }
            }, 150);
        }

        // Setup tooltip hover detection
        document.getElementById('tooltip').addEventListener('mouseenter', () => {
            isTooltipHovered = true;
            if (tooltipTimeout) clearTimeout(tooltipTimeout);
        });

        document.getElementById('tooltip').addEventListener('mouseleave', () => {
            isTooltipHovered = false;
            handleMouseOut();
        });

        function handleNodeClick(event, d, shouldPan = true) {
            selectedNode = d;
            showNodeDetail(d);

            // Pan to the node
            if (shouldPan && d.id !== undefined) {
                panToNode(d.id);
            }

            // Switch to detail tab
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelector('[data-tab="detail"]').classList.add('active');
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById('detail-tab').classList.add('active');
        }

        function showNodeDetail(node) {
            const connections = graphData.edges
                .filter(e => e.source_id === node.id || e.target_id === node.id)
                .map(e => {
                    const otherId = e.source_id === node.id ? e.target_id : e.source_id;
                    const other = graphData.nodes.find(n => n.id === otherId);
                    return { node: other, reason: e.reason };
                });

            // Find clusters this node belongs to
            const nodeClusters = clusters.filter(c =>
                c.nodes.some(n => n.id === node.id)
            );

            const twitterHandle = node.username.replace('@', '');
            const hasLink = node.link && node.link.startsWith('http');

            const detailHtml = `
                <div class="node-detail">
                    <div class="summary">
                        ${node.summary || 'No summary available'}
                        ${hasLink ? `<a href="${node.link}" target="_blank" class="tweet-link-icon" title="View original tweet">↗</a>` : ''}
                    </div>
                    <div class="detail-meta">
                        <a href="https://twitter.com/${twitterHandle}" target="_blank" class="detail-author">${node.username}</a>
                        <span class="detail-date">${node.date}</span>
                    </div>
                    ${nodeClusters.length > 0 ? `
                        <div class="node-clusters">
                            <span class="cluster-label-text">Cluster:</span>
                            ${nodeClusters.map(c => `
                                <span class="node-cluster-tag" data-cluster-id="${c.id}" style="background: ${c.color}20; color: ${c.color}; border: 1px solid ${c.color}40;">
                                    <span class="cluster-dot" style="background: ${c.color}"></span>
                                    ${c.name}
                                </span>
                            `).join('')}
                        </div>
                    ` : ''}

                    <div class="connections-header" style="margin-top: 20px;">
                        Connected Ideas (${connections.length})
                    </div>
                    ${connections.map(c => {
                        const cHandle = c.node.username.replace('@', '');
                        const cHasLink = c.node.link && c.node.link.startsWith('http');
                        return `
                        <div class="connection-item clickable-connection" data-node-id="${c.node.id}">
                            <div class="connection-content">
                                <div class="connection-text-wrap">
                                    ${c.node.summary || 'No summary'} — <a href="https://twitter.com/${cHandle}" target="_blank" class="connection-author" onclick="event.stopPropagation();">${c.node.username}</a>
                                </div>
                                ${cHasLink ? `<a href="${c.node.link}" target="_blank" class="connection-link-icon" onclick="event.stopPropagation();" title="View original tweet">↗</a>` : ''}
                            </div>
                            <div class="reason">${c.reason}</div>
                        </div>
                    `}).join('')}
                </div>
            `;

            const nodeDetailEl = document.getElementById('nodeDetail');
            nodeDetailEl.classList.remove('empty-state');
            nodeDetailEl.innerHTML = detailHtml;

            // Scroll detail panel to top
            document.querySelector('.panel-content').scrollTop = 0;

            // Add click handlers to cluster tags
            document.querySelectorAll('.node-cluster-tag').forEach(tag => {
                tag.addEventListener('click', () => {
                    const clusterId = parseInt(tag.dataset.clusterId);
                    highlightCluster(clusterId);
                    showClusterInSidebar(clusterId);
                });
            });

            // Add click handlers to connections
            document.querySelectorAll('.clickable-connection').forEach(item => {
                item.addEventListener('click', () => {
                    const nodeId = parseInt(item.dataset.nodeId);
                    const targetNode = graphData.nodes.find(n => n.id === nodeId);
                    if (targetNode) {
                        panToNode(nodeId);
                        showNodeDetail(targetNode);
                        // Highlight the node briefly
                        d3.selectAll('.node-bg')
                            .attr('stroke-width', n => n.id === nodeId ? 2 : 1)
                            .attr('opacity', n => n.id === nodeId ? 1 : 0.5);
                        setTimeout(() => {
                            d3.selectAll('.node-bg')
                                .attr('stroke-width', 1)
                                .attr('opacity', 1);
                        }, 2000);
                    }
                });
            });
        }

        function updateStats() {
            document.getElementById('totalIdeas').textContent = graphData.nodes.length;
            document.getElementById('totalConnections').textContent = graphData.edges.length;
            document.getElementById('totalClusters').textContent = clusters.length;
        }

        function renderClusters() {
            const container = document.getElementById('clusterList');

            // Sort by node count descending
            const sortedClusters = [...clusters].sort((a, b) => b.nodes.length - a.nodes.length);

            container.innerHTML = sortedClusters.map(cluster => `
                <div class="cluster-card" data-cluster="${cluster.id}">
                    <div class="cluster-header">
                        <div class="cluster-color" style="background: ${cluster.color}"></div>
                        <div class="cluster-title">${cluster.name}</div>
                        <div class="cluster-count">${cluster.nodes.length} ${cluster.nodes.length === 1 ? 'voice' : 'voices'}</div>
                    </div>
                    ${cluster.consensus ? `
                        <div class="consensus-badge ${cluster.consensus.toLowerCase()}">
                            ${cluster.consensus} Consensus
                        </div>
                    ` : ''}
                    <div class="cluster-summary">${cluster.summary}</div>
                    ${cluster.demands && cluster.demands.length > 0 ? `
                        <div class="cluster-actions">
                            <div class="actions-label">Key Issues:</div>
                            ${cluster.demands.slice(0, 3).map((demand, idx) => `
                                <div class="action-link issue-link" data-demand="${demand.description}" data-cluster-id="${cluster.id}">
                                    <span class="action-bullet">→</span>
                                    <span class="action-title-text">${demand.description}</span>
                                    <span class="action-voices">${demand.count || 1} voice${(demand.count || 1) === 1 ? '' : 's'}</span>
                                </div>
                            `).join('')}
                            ${cluster.demands.length > 3 ? `<div class="more-issues">+${cluster.demands.length - 3} more...</div>` : ''}
                        </div>
                    ` : cluster.action ? `
                        <div class="cluster-action">
                            <strong>Action:</strong> ${cluster.action}
                        </div>
                    ` : ''}
                    <div class="cluster-items">
                        ${cluster.nodes.map(n => {
                            const handle = (n.username || '').replace(/^@+/, '');
                            return `
                            <div class="item-mini" data-node-id="${n.id}">
                                ${(n.summary || '').substring(0, 100)}${(n.summary || '').length > 100 ? '...' : ''} — <a href="https://twitter.com/${handle}" target="_blank" class="username-link" onclick="event.stopPropagation();">@${handle}</a>
                            </div>
                        `}).join('')}
                    </div>
                </div>
            `).join('');

            // Add click handlers
            container.querySelectorAll('.cluster-card').forEach(card => {
                card.addEventListener('click', (e) => {
                    // Handle issue link clicks - jump to Actionable tab (Demands view)
                    if (e.target.closest('.issue-link')) {
                        e.stopPropagation();
                        const issueLink = e.target.closest('.issue-link');
                        const demandDescription = issueLink.dataset.demand;
                        jumpToDemand(demandDescription);
                        return;
                    }
                    // Handle action link clicks - jump to Actionable tab (Policy Proposals view)
                    if (e.target.closest('.action-link')) {
                        e.stopPropagation();
                        const actionLink = e.target.closest('.action-link');
                        const actionTitle = actionLink.dataset.actionTitle;
                        jumpToActionable(actionTitle);
                        return;
                    }
                    // Don't toggle if clicking on an item
                    if (e.target.closest('.item-mini')) {
                        const nodeId = parseInt(e.target.closest('.item-mini').dataset.nodeId);
                        const node = graphData.nodes.find(n => n.id === nodeId);
                        if (node) {
                            handleNodeClick(null, node);
                        }
                        return;
                    }
                    const clusterId = parseInt(card.dataset.cluster);
                    card.classList.toggle('expanded');
                    highlightCluster(clusterId);
                });

                // Hover highlighting
                card.addEventListener('mouseenter', () => {
                    const clusterId = parseInt(card.dataset.cluster);
                    highlightClusterNodes(clusterId, true);
                });

                card.addEventListener('mouseleave', () => {
                    const clusterId = parseInt(card.dataset.cluster);
                    highlightClusterNodes(clusterId, false);
                });
            });
        }

        // Show cluster in sidebar - switch tab, scroll to card, highlight it
        function showClusterInSidebar(clusterId) {
            // Switch to Clusters tab
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelector('[data-tab="clusters"]').classList.add('active');
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById('clusters-tab').classList.add('active');

            // Find and highlight the cluster card
            const card = document.querySelector(`.cluster-card[data-cluster="${clusterId}"]`);
            if (card) {
                // Remove selected from other cards
                document.querySelectorAll('.cluster-card').forEach(c => c.classList.remove('selected'));

                // Select and expand this card
                card.classList.add('selected', 'expanded');

                // Scroll into view
                card.scrollIntoView({ behavior: 'smooth', block: 'center' });

                // Remove highlight after a delay
                setTimeout(() => {
                    card.classList.remove('selected');
                }, 3000);
            }
        }

        // Jump to Actionable tab (Demands view) and scroll to specific demand
        function jumpToDemand(demandDescription) {
            // Switch to Actionable tab
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelector('[data-tab="actionable"]').classList.add('active');
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById('actionable-tab').classList.add('active');

            // Switch to demands view if not already
            if (actionableViewMode !== 'demands') {
                actionableViewMode = 'demands';
                updateActionableTab();
            }

            // Find and highlight the demand item
            setTimeout(() => {
                const demandItems = document.querySelectorAll('.demand-item');
                for (const item of demandItems) {
                    const titleEl = item.querySelector('h4');
                    if (titleEl && titleEl.textContent.trim() === demandDescription) {
                        // Remove highlight from other items
                        demandItems.forEach(i => i.classList.remove('highlighted'));

                        // Highlight this item
                        item.classList.add('highlighted');
                        item.scrollIntoView({ behavior: 'smooth', block: 'center' });

                        // Remove highlight after delay
                        setTimeout(() => {
                            item.classList.remove('highlighted');
                        }, 3000);
                        break;
                    }
                }
            }, 150);
        }

        // Jump to Actionable tab and scroll to specific action
        function jumpToActionable(actionTitle) {
            // Switch to Actionable tab
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelector('[data-tab="actionable"]').classList.add('active');
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById('actionable-tab').classList.add('active');

            // Switch to proposals view if not already
            if (actionableViewMode !== 'proposals') {
                actionableViewMode = 'proposals';
                updateActionableTab();
            }

            // Find and highlight the action item
            setTimeout(() => {
                const actionItems = document.querySelectorAll('.actionable-item');
                for (const item of actionItems) {
                    const titleEl = item.querySelector('h4');
                    if (titleEl && titleEl.textContent.trim() === actionTitle) {
                        // Remove highlight from other items
                        actionItems.forEach(i => i.classList.remove('highlighted'));

                        // Highlight this item
                        item.classList.add('highlighted');
                        item.scrollIntoView({ behavior: 'smooth', block: 'center' });

                        // Remove highlight after delay
                        setTimeout(() => {
                            item.classList.remove('highlighted');
                        }, 3000);
                        break;
                    }
                }
            }, 150);
        }

        function highlightCluster(clusterId, shouldPan = true) {
            const cluster = clusters.find(c => c.id === clusterId);
            if (!cluster) return;

            const clusterNodeIds = new Set(cluster.nodes.map(n => n.id));

            // Pan to the cluster nodes
            if (shouldPan) {
                panToNodes([...clusterNodeIds]);
            }

            d3.selectAll('.node-bg')
                .attr('stroke-width', n => clusterNodeIds.has(n.id) ? 2 : 1)
                .attr('opacity', n => clusterNodeIds.has(n.id) ? 1 : 0.4);
            d3.selectAll('.node-label')
                .attr('opacity', n => clusterNodeIds.has(n.id) ? 1 : 0.2);

            d3.selectAll('.links line')
                .attr('stroke', l =>
                    clusterNodeIds.has(l.source.id) && clusterNodeIds.has(l.target.id) ? '#e07a5f' : '#4a5568'
                )
                .attr('stroke-opacity', l =>
                    clusterNodeIds.has(l.source.id) && clusterNodeIds.has(l.target.id) ? 1 : 0.15
                )
                .attr('stroke-width', l =>
                    clusterNodeIds.has(l.source.id) && clusterNodeIds.has(l.target.id) ? 2 : 1
                );

            // Reset highlighting after delay (but keep pan position)
            setTimeout(() => {
                d3.selectAll('.node-bg')
                    .attr('stroke-width', 1)
                    .attr('opacity', 1);
                d3.selectAll('.node-label').attr('opacity', 1);
                d3.selectAll('.links line')
                    .attr('stroke', '#4a5568')
                    .attr('stroke-opacity', 0.6)
                    .attr('stroke-width', 1.5);
            }, 3000);
        }

        let actionableViewMode = 'demands'; // 'demands' or 'proposals'

        function renderActionable() {
            const container = document.getElementById('actionableList');

            // Collect all synthesized actions across clusters
            const allActions = [];
            clusters.forEach(cluster => {
                if (cluster.synthesized_actions && cluster.synthesized_actions.length > 0) {
                    cluster.synthesized_actions.forEach(action => {
                        allActions.push({
                            ...action,
                            cluster: cluster,
                            color: cluster.color,
                            topic: cluster.topic
                        });
                    });
                }
            });

            // Collect all demands across clusters with actual tweet data
            const allDemands = [];
            clusters.forEach(cluster => {
                if (cluster.demands && cluster.demands.length > 0) {
                    cluster.demands.forEach(demand => {
                        // Get actual tweet data for this demand
                        const tweets = (demand.tweet_ids || []).map(id => {
                            const node = graphData.nodes.find(n => n.id === id);
                            if (node) {
                                return {
                                    id: node.id,
                                    username: node.username,
                                    summary: node.summary,
                                    link: node.link,
                                    date: node.date
                                };
                            }
                            return null;
                        }).filter(Boolean);

                        // Check if this demand already exists (dedup across clusters)
                        const existing = allDemands.find(d => d.description === demand.description);
                        if (existing) {
                            existing.count += demand.count;
                            existing.clusters.push(cluster);
                            // Merge tweets, avoiding duplicates
                            tweets.forEach(t => {
                                if (!existing.tweets.find(et => et.id === t.id)) {
                                    existing.tweets.push(t);
                                }
                            });
                        } else {
                            allDemands.push({
                                ...demand,
                                tweets: tweets,
                                clusters: [cluster],
                                color: cluster.color,
                                topic: cluster.topic
                            });
                        }
                    });
                }
            });

            // Sort demands by voice count
            allDemands.sort((a, b) => (b.count || 0) - (a.count || 0));

            // Sort by voices represented
            allActions.sort((a, b) => (b.voices_represented || 0) - (a.voices_represented || 0));

            // If no synthesized actions, fall back to old display
            if (allActions.length === 0) {
                const actionable = clusters
                    .filter(c => c.nodes.length > 0)
                    .sort((a, b) => b.nodes.length - a.nodes.length)
                    .map((cluster, idx) => ({
                        rank: idx + 1,
                        title: cluster.name,
                        topic: cluster.topic,
                        support: cluster.nodes.length,
                        consensus: cluster.consensus || 'Medium',
                        action: cluster.action || `Review ${cluster.nodes.length} suggestions about ${cluster.topic.toLowerCase()}`,
                        description: consolidateIdeas(cluster.nodes),
                        color: cluster.color,
                        nodes: cluster.nodes
                    }));

                container.innerHTML = `
                    <div class="actionable-header">
                        <h3>Priority Actions for City Officials</h3>
                        <p>Ranked by citizen support level</p>
                    </div>
                    ${actionable.map(item => `
                        <div class="actionable-item" data-cluster-id="${clusters.find(c => c.name === item.title)?.id}">
                            <div class="actionable-rank">#${item.rank}</div>
                            <div class="actionable-content">
                                <div class="actionable-title-row">
                                    <h4 style="border-left: 3px solid ${item.color}; padding-left: 10px;">${item.title}</h4>
                                    <span class="topic-tag" style="background: ${item.color}20; color: ${item.color}; border: 1px solid ${item.color}40;">${item.topic}</span>
                                </div>
                                <div class="support-bar">
                                    <div class="support-fill" style="width: ${Math.min(100, item.support * 12)}%; background: ${item.color};"></div>
                                </div>
                                <div class="support-text">${item.support} citizen${item.support === 1 ? '' : 's'} • ${item.consensus} consensus</div>
                                <div class="action-text">${item.action}</div>
                                <div class="description">${item.description}</div>
                            </div>
                        </div>
                    `).join('')}
                `;
            } else {
                // Build the view toggle header
                const headerHtml = `
                    <div class="actionable-header">
                        <div class="actionable-toggle">
                            <button class="toggle-btn ${actionableViewMode === 'demands' ? 'active' : ''}" data-mode="demands">
                                Citizen Demands
                            </button>
                            <button class="toggle-btn ${actionableViewMode === 'proposals' ? 'active' : ''}" data-mode="proposals">
                                Policy Proposals
                            </button>
                        </div>
                        <p>${actionableViewMode === 'demands'
                            ? 'Synthesized issues extracted from citizen input'
                            : 'AI-generated implementable policy actions'}</p>
                    </div>
                `;

                let contentHtml = '';

                if (actionableViewMode === 'demands') {
                    // Demands view - show synthesized issues
                    contentHtml = allDemands.map((demand, idx) => `
                        <div class="actionable-item demand-item" data-cluster-id="${demand.clusters[0].id}" data-demand-idx="${idx}">
                            <div class="actionable-rank">#${idx + 1}</div>
                            <div class="actionable-content">
                                <div class="actionable-title-row">
                                    <h4 style="border-left: 3px solid ${demand.color}; padding-left: 10px;">${demand.description}</h4>
                                    <span class="topic-tag" style="background: ${demand.color}20; color: ${demand.color}; border: 1px solid ${demand.color}40;">${demand.topic}</span>
                                </div>
                                <div class="support-bar">
                                    <div class="support-fill" style="width: ${Math.min(100, (demand.count || 1) * 20)}%; background: ${demand.color};"></div>
                                </div>
                                <div class="support-text">${demand.count || 1} voice${(demand.count || 1) === 1 ? '' : 's'}</div>
                                ${demand.tweets && demand.tweets.length > 0 ? `
                                    <div class="tweets-toggle" onclick="event.stopPropagation(); this.closest('.demand-item').classList.toggle('tweets-expanded');">
                                        <span class="toggle-icon">▶</span> View ${demand.tweets.length} supporting tweet${demand.tweets.length === 1 ? '' : 's'}
                                    </div>
                                    <div class="demand-tweets">
                                        ${demand.tweets.map(t => {
                                            const handle = (t.username || '').replace(/^@+/, '');
                                            const hasLink = t.link && t.link.startsWith('http');
                                            return `
                                            <div class="demand-tweet">
                                                <div class="tweet-content">${t.summary || 'No content'}</div>
                                                <div class="tweet-meta">
                                                    <a href="https://twitter.com/${handle}" target="_blank" class="tweet-author" onclick="event.stopPropagation();">@${handle}</a>
                                                    ${t.date ? `<span class="tweet-date">${t.date}</span>` : ''}
                                                    ${hasLink ? `<a href="${t.link}" target="_blank" class="tweet-link" onclick="event.stopPropagation();">View tweet →</a>` : ''}
                                                </div>
                                            </div>
                                        `}).join('')}
                                    </div>
                                ` : ''}
                            </div>
                        </div>
                    `).join('');
                } else {
                    // Proposals view - show policy proposals
                    contentHtml = allActions.map((action, idx) => `
                        <div class="actionable-item synthesized-action" data-cluster-id="${action.cluster.id}">
                            <div class="actionable-rank">#${idx + 1}</div>
                            <div class="actionable-content">
                                <div class="actionable-title-row">
                                    <h4 style="border-left: 3px solid ${action.color}; padding-left: 10px;">${action.title}</h4>
                                    <span class="topic-tag" style="background: ${action.color}20; color: ${action.color}; border: 1px solid ${action.color}40;">${action.topic}</span>
                                </div>
                                <div class="support-bar">
                                    <div class="support-fill" style="width: ${Math.min(100, (action.voices_represented || 1) * 15)}%; background: ${action.color};"></div>
                                </div>
                                <div class="support-text">${action.voices_represented || 1} voice${(action.voices_represented || 1) === 1 ? '' : 's'} represented</div>
                                <div class="proposal-text">${action.proposal}</div>
                                ${action.supporting_demands && action.supporting_demands.length > 0 ? `
                                    <div class="supporting-demands">
                                        <span class="demands-label">Based on demands:</span>
                                        ${action.supporting_demands.map(d => `<span class="demand-chip clickable" data-demand="${d}">${d}</span>`).join('')}
                                    </div>
                                ` : ''}
                            </div>
                        </div>
                    `).join('');
                }

                container.innerHTML = headerHtml + contentHtml;

                // Add toggle handlers
                container.querySelectorAll('.toggle-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        actionableViewMode = btn.dataset.mode;
                        renderActionable();
                    });
                });

                // Add demand chip click handlers (jump to demands view and highlight)
                container.querySelectorAll('.demand-chip.clickable').forEach(chip => {
                    chip.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const demandText = chip.dataset.demand;
                        actionableViewMode = 'demands';
                        renderActionable();
                        // Highlight the matching demand after re-render
                        setTimeout(() => {
                            const demandItems = container.querySelectorAll('.demand-item h4');
                            for (const item of demandItems) {
                                if (item.textContent.includes(demandText)) {
                                    const demandCard = item.closest('.demand-item');
                                    demandCard.classList.add('highlighted');
                                    demandCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                    setTimeout(() => demandCard.classList.remove('highlighted'), 3000);
                                    break;
                                }
                            }
                        }, 100);
                    });
                });

                // Add topic tag click handlers (highlight topic on graph)
                container.querySelectorAll('.topic-tag').forEach(tag => {
                    tag.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const topic = tag.textContent.trim();
                        highlightTopic(topic);
                    });
                });
            }

            // Add click handlers to highlight clusters
            container.querySelectorAll('.actionable-item').forEach(item => {
                item.addEventListener('click', () => {
                    const clusterId = parseInt(item.dataset.clusterId);
                    if (!isNaN(clusterId)) {
                        highlightCluster(clusterId);
                    }
                });
            });
        }

        function consolidateIdeas(nodes) {
            const summaries = nodes.map(n => n.summary).filter(s => s && s.length > 10);
            if (summaries.length === 0) return 'Various related urban improvement suggestions.';

            if (summaries.length === 1) return summaries[0];

            // Create bullet points
            return summaries.slice(0, 3).map(s => `• ${s.substring(0, 150)}${s.length > 150 ? '...' : ''}`).join('<br>');
        }

        function setupLegend() {
            const legend = document.getElementById('legend');
            const topics = [...new Set(graphData.nodes.map(n => n.primaryTopic))];

            topics.forEach((topic) => {
                const color = clusterColors[topic] || fallbackColors[0];
                const count = graphData.nodes.filter(n => n.primaryTopic === topic).length;
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.innerHTML = `
                    <div class="legend-color" style="background: ${color}"></div>
                    <span>${topic}</span>
                    <span style="color: #666; font-size: 0.75rem; margin-left: auto;">${count}</span>
                `;
                item.addEventListener('click', () => highlightTopic(topic));
                legend.appendChild(item);
            });
        }

        // Cluster overlay labels (Google Maps style)
        let clusterLabels = [];
        let currentZoomScale = 1;

        function setupClusterOverlay() {
            const overlay = document.getElementById('clusterOverlay');
            overlay.innerHTML = '';
            clusterLabels = [];

            // Create a label for each cluster with 2+ nodes
            clusters.filter(c => c.nodes.length >= 2).forEach(cluster => {
                const label = document.createElement('div');
                label.className = 'cluster-label';
                label.innerHTML = `
                    <span class="dot" style="background: ${cluster.color}"></span>
                    ${cluster.name}
                    <span class="count">${cluster.nodes.length}</span>
                `;

                // Click to zoom to cluster and show in sidebar
                label.addEventListener('click', () => {
                    highlightCluster(cluster.id);
                    showClusterInSidebar(cluster.id);
                });

                // Hover to highlight cluster nodes
                label.addEventListener('mouseenter', () => {
                    highlightClusterNodes(cluster.id, true);
                });
                label.addEventListener('mouseleave', () => {
                    highlightClusterNodes(cluster.id, false);
                });

                overlay.appendChild(label);
                clusterLabels.push({ element: label, cluster: cluster });
            });

            updateClusterLabelPositions();
        }

        function getClusterCentroid(cluster) {
            // Get actual node objects from graphData (they have x/y from simulation)
            const nodes = cluster.nodes
                .map(n => graphData.nodes.find(gn => gn.id === n.id))
                .filter(n => n && n.x !== undefined && n.y !== undefined);

            if (nodes.length === 0) {
                // Fallback to center of screen if no positioned nodes
                return { x: window.graphWidth / 2, y: window.graphHeight / 2 };
            }

            const sumX = nodes.reduce((sum, n) => sum + n.x + calcNodeWidth(n) / 2, 0);
            const sumY = nodes.reduce((sum, n) => sum + n.y + calcNodeHeight(n) / 2, 0);
            return {
                x: sumX / nodes.length,
                y: sumY / nodes.length
            };
        }

        function updateClusterLabelPositions() {
            if (!window.svgElement) return;

            const transform = d3.zoomTransform(window.svgElement.node());
            currentZoomScale = transform.k;

            // Determine visibility based on mode
            const overlay = document.getElementById('clusterOverlay');
            const graphPanel = document.querySelector('.graph-panel');
            let showOverlay = false;
            if (overlayMode === 'always') {
                showOverlay = true;
            } else if (overlayMode === 'never') {
                showOverlay = false;
            } else { // auto
                showOverlay = currentZoomScale < 0.7;
            }
            overlay.style.opacity = showOverlay ? 1 : 0;
            // Keep overlay pointer-events: none so panning works
            // Individual labels have pointer-events: auto via CSS

            // Toggle overview mode visual effect
            if (showOverlay) {
                graphPanel.classList.add('overview-mode');
            } else {
                graphPanel.classList.remove('overview-mode');
            }

            clusterLabels.forEach(({ element, cluster }) => {
                const centroid = getClusterCentroid(cluster);
                // Apply the same transform as the graph
                const screenX = centroid.x * transform.k + transform.x;
                const screenY = centroid.y * transform.k + transform.y;
                element.style.left = `${screenX}px`;
                element.style.top = `${screenY}px`;
            });
        }

        // Hook into simulation tick to update label positions
        function hookClusterLabelUpdates() {
            if (window.simulation) {
                const originalTick = window.simulation.on('tick');
                window.simulation.on('tick', () => {
                    if (originalTick) originalTick();
                    updateClusterLabelPositions();
                });
            }
        }

        // Setup overlay toggle buttons
        function setupOverlayToggle() {
            document.querySelectorAll('.overlay-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.overlay-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    overlayMode = btn.dataset.mode;
                    updateClusterLabelPositions();
                });
            });

            // Fix scroll passthrough - forward wheel events from overlay to SVG
            const overlay = document.getElementById('clusterOverlay');
            overlay.addEventListener('wheel', (e) => {
                e.preventDefault();
                // Forward wheel event to SVG for zoom
                const svgNode = window.svgElement?.node();
                if (svgNode) {
                    const wheelEvent = new WheelEvent('wheel', {
                        deltaX: e.deltaX,
                        deltaY: e.deltaY,
                        deltaMode: e.deltaMode,
                        clientX: e.clientX,
                        clientY: e.clientY,
                        screenX: e.screenX,
                        screenY: e.screenY,
                        bubbles: true,
                        cancelable: true
                    });
                    svgNode.dispatchEvent(wheelEvent);
                }
            }, { passive: false });
        }

        // Highlight nodes in a cluster (for hover on cluster labels)
        function highlightClusterNodes(clusterId, highlight) {
            const cluster = clusters.find(c => c.id === clusterId);
            if (!cluster) return;

            const clusterNodeIds = new Set(cluster.nodes.map(n => n.id));

            if (highlight) {
                // Highlight this cluster's nodes
                d3.selectAll('.node-bg')
                    .attr('stroke-width', n => clusterNodeIds.has(n.id) ? 2 : 1)
                    .attr('opacity', n => clusterNodeIds.has(n.id) ? 1 : 0.3);
                d3.selectAll('.node-label')
                    .attr('opacity', n => clusterNodeIds.has(n.id) ? 1 : 0.15);

                d3.selectAll('.links line')
                    .attr('stroke', l =>
                        clusterNodeIds.has(l.source.id) && clusterNodeIds.has(l.target.id) ? cluster.color : '#4a5568'
                    )
                    .attr('stroke-opacity', l =>
                        clusterNodeIds.has(l.source.id) && clusterNodeIds.has(l.target.id) ? 1 : 0.1
                    )
                    .attr('stroke-width', l =>
                        clusterNodeIds.has(l.source.id) && clusterNodeIds.has(l.target.id) ? 2.5 : 1
                    );

                // Also highlight the label
                const labelEl = clusterLabels.find(cl => cl.cluster.id === clusterId)?.element;
                if (labelEl) labelEl.classList.add('hovered');
            } else {
                // Reset highlights
                d3.selectAll('.node-bg')
                    .attr('stroke-width', 1)
                    .attr('opacity', 1);
                d3.selectAll('.node-label').attr('opacity', 1);
                d3.selectAll('.links line')
                    .attr('stroke', '#4a5568')
                    .attr('stroke-opacity', 0.6)
                    .attr('stroke-width', 1.5);

                // Remove highlight from label
                const labelEl = clusterLabels.find(cl => cl.cluster.id === clusterId)?.element;
                if (labelEl) labelEl.classList.remove('hovered');
            }
        }

        function highlightTopic(topic) {
            // Collect node IDs for this topic
            const topicNodeIds = graphData.nodes
                .filter(n => n.primaryTopic === topic)
                .map(n => n.id);

            // Pan to show all nodes of this topic
            if (topicNodeIds.length > 0) {
                panToNodes(topicNodeIds);
            }

            d3.selectAll('.node-bg')
                .attr('stroke-width', n => n.primaryTopic === topic ? 2 : 1)
                .attr('opacity', n => n.primaryTopic === topic ? 1 : 0.4);
            d3.selectAll('.node-label')
                .attr('opacity', n => n.primaryTopic === topic ? 1 : 0.2);

            setTimeout(() => {
                d3.selectAll('.node-bg')
                    .attr('stroke-width', 1)
                    .attr('opacity', 1);
                d3.selectAll('.node-label').attr('opacity', 1);
            }, 2000);
        }

        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');

                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                document.getElementById(`${tab.dataset.tab}-tab`).classList.add('active');
            });
        });

        // Search functionality
        document.getElementById('searchInput').addEventListener('input', (e) => {
            const query = e.target.value.toLowerCase();

            if (!query) {
                d3.selectAll('.node-bg')
                    .attr('stroke-width', 1)
                    .attr('opacity', 1);
                d3.selectAll('.node-label').attr('opacity', 1);
                return;
            }

            d3.selectAll('.node-bg')
                .attr('stroke-width', n => {
                    const text = `${n.username} ${n.summary}`.toLowerCase();
                    return text.includes(query) ? 2 : 1;
                })
                .attr('opacity', n => {
                    const text = `${n.username} ${n.summary}`.toLowerCase();
                    return text.includes(query) ? 1 : 0.3;
                });
            d3.selectAll('.node-label')
                .attr('opacity', n => {
                    const text = `${n.username} ${n.summary}`.toLowerCase();
                    return text.includes(query) ? 1 : 0.2;
                });
        });

        // Grok chat handling
        const grokChatForm = document.getElementById('grokChatForm');
        const grokChatHistory = document.getElementById('grokChatHistory');
        const grokPromptInput = document.getElementById('grokPrompt');
        const grokCountInput = document.getElementById('grokCount');
        const grokModelInput = document.getElementById('grokModel');
        const grokAllowedInput = document.getElementById('grokAllowed');
        const grokExcludedInput = document.getElementById('grokExcluded');
        const grokStatusEl = document.getElementById('grokStatus');
        const grokSendBtn = document.getElementById('grokSendBtn');
        const grokClearBtn = document.getElementById('grokClearBtn');
        const grokSendDefaultIcon = `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M5 12h14M12 5l7 7-7 7"/></svg>`;
        const grokSendLoadingIcon = `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="grok-spin"><circle cx="12" cy="12" r="10" stroke-dasharray="31.4 31.4" stroke-linecap="round"/></svg>`;

        function escapeHtml(str) {
            if (!str && str !== 0) return '';
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        function parseHandleInput(value) {
            if (!value) return null;
            const handles = value
                .split(',')
                .map(h => h.trim().replace(/^@/, ''))
                .filter(Boolean);
            return handles.length ? handles : null;
        }

        function appendGrokMessage(role, contentHtml) {
            if (!grokChatHistory) return;
            const hint = grokChatHistory.querySelector('.grok-chat-hint');
            if (hint) hint.remove();
            const message = document.createElement('div');
            message.className = `grok-chat-message ${role}`;
            const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            const sender = role === 'user' ? 'You' : 'Grok';
            message.innerHTML = `
                <div class="grok-chat-meta">
                    <span>${sender}</span>
                    <span>${timestamp}</span>
                </div>
                <div class="grok-chat-text">${contentHtml}</div>
            `;
            grokChatHistory.appendChild(message);
            grokChatHistory.scrollTop = grokChatHistory.scrollHeight;
        }

        function saveGrokResultsAsCSV() {
            const data = window.lastGrokResults;
            if (!data || !data.rows || data.rows.length === 0) {
                alert('No results to save');
                return;
            }

            // Build CSV content
            const headers = ['Date', 'Username', 'Summary/Quote', 'Link'];
            const csvRows = [headers.join(',')];

            data.rows.forEach(row => {
                const date = row.Date || row.date || '';
                const username = (row.Username || row.username || '').replace(/^@/, '');
                const summary = (row['Summary/Quote'] || row.summary || '').replace(/"/g, '""');
                const link = row.Link || row.link || '';
                csvRows.push(`"${date}","@${username}","${summary}","${link}"`);
            });

            const csvContent = csvRows.join('\n');
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);

            // Create download link
            const a = document.createElement('a');
            a.href = url;
            const timestamp = new Date().toISOString().slice(0, 10);
            const location = (data.location || 'grok-search').replace(/[^a-zA-Z0-9]/g, '_');
            a.download = `${location}_${timestamp}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function renderGrokResponse(data) {
            const rows = Array.isArray(data?.rows) ? data.rows : [];
            if (rows.length > 0) {
                const intro = data.location
                    ? `${rows.length} posts mentioning "${escapeHtml(data.location)}"`
                    : `${rows.length} posts retrieved`;

                // Store last results for CSV export
                window.lastGrokResults = data;

                // Helper to validate URLs
                const isValidUrl = (url) => url && (url.startsWith('http://') || url.startsWith('https://'));

                return `
                    <div class="grok-result">
                        <div class="grok-result-meta">
                            <span>${intro}</span>
                            <div class="grok-result-actions">
                                <button class="grok-add-btn" onclick="addGrokResultsToProject(window.lastGrokResults?.rows)">Add to Graph</button>
                                <button class="grok-save-csv-btn" onclick="saveGrokResultsAsCSV()">Save CSV</button>
                            </div>
                        </div>
                        ${rows.map(row => {
                            const link = row.Link || row.link || '';
                            const validLink = isValidUrl(link) ? link : '';
                            return `
                            <div class="grok-row">
                                <div class="grok-row-header">
                                    <span>${escapeHtml(row.Date || row.date || '')}</span>
                                    <span>@${escapeHtml((row.Username || row.username || '').replace(/^@/, ''))}</span>
                                </div>
                                <p>${escapeHtml(row['Summary/Quote'] || row.summary || '')}</p>
                                ${validLink ? `<a class="grok-row-link" href="${escapeHtml(validLink)}" target="_blank" rel="noopener">Open post</a>` : ''}
                            </div>
                        `}).join('')}
                    </div>
                `;
            }

            if (data.csv_text) {
                return `<pre class="grok-raw">${escapeHtml(data.csv_text)}</pre>`;
            }

            if (data.error) {
                return `<span class="grok-error">⚠️ ${escapeHtml(data.error)}</span>`;
            }

            return `<span>No data returned from Grok.</span>`;
        }

        function setGrokStatus(message, variant = 'muted') {
            if (!grokStatusEl) return;
            grokStatusEl.textContent = message || '';
            grokStatusEl.classList.remove('error', 'success', 'loading');
            if (variant && variant !== 'muted') {
                grokStatusEl.classList.add(variant);
            }
        }

        function setGrokLoading(isLoading) {
            if (!grokSendBtn) return;
            if (isLoading) {
                grokSendBtn.disabled = true;
                grokSendBtn.classList.add('loading');
                grokSendBtn.innerHTML = grokSendLoadingIcon;
            } else {
                grokSendBtn.disabled = false;
                grokSendBtn.classList.remove('loading');
                grokSendBtn.innerHTML = grokSendDefaultIcon;
            }
        }

        document.querySelectorAll('[data-grok-prompt]').forEach(btn => {
            btn.addEventListener('click', () => {
                const prompt = btn.getAttribute('data-grok-prompt');
                const count = parseInt(btn.getAttribute('data-grok-count') || '', 10);
                if (prompt && grokPromptInput) {
                    grokPromptInput.value = prompt;
                    grokPromptInput.focus();
                }
                if (!Number.isNaN(count) && grokCountInput) {
                    grokCountInput.value = count;
                }
            });
        });

        if (grokClearBtn && grokChatHistory) {
            grokClearBtn.addEventListener('click', () => {
                grokChatHistory.innerHTML = `
                    <div class="grok-chat-hint">
                        Ask Grok to search X for emerging urbanist ideas. Provide a topic or borough; filters are optional.
                    </div>
                `;
                setGrokStatus('');
            });
        }

        if (grokChatForm) {
            grokChatForm.addEventListener('submit', async (event) => {
                event.preventDefault();
                const prompt = (grokPromptInput?.value || '').trim();
                if (!prompt) return;

                appendGrokMessage('user', escapeHtml(prompt));
                setGrokStatus('Contacting Grok for the latest X posts...', 'loading');
                setGrokLoading(true);

                const payload = { prompt };
                const countValue = parseInt(grokCountInput?.value || '10', 10);
                payload.count = Number.isNaN(countValue) ? 10 : countValue;
                payload.model = (grokModelInput?.value || 'grok-4-1-fast').trim();

                const allowed = parseHandleInput(grokAllowedInput?.value);
                if (allowed) payload.allowed_handles = allowed;
                const excluded = parseHandleInput(grokExcludedInput?.value);
                if (excluded) payload.excluded_handles = excluded;
                try {
                    const response = await fetch('/api/grok-search', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    const data = await response.json();
                    if (!response.ok) {
                        throw new Error(data.error || 'Grok search failed');
                    }
                    appendGrokMessage('assistant', renderGrokResponse(data));
                    setGrokStatus(`Completed via ${data.model || 'grok-4-1-fast'}.`, 'success');
                } catch (err) {
                    appendGrokMessage('assistant', `<span class="grok-error">⚠️ ${escapeHtml(err.message || String(err))}</span>`);
                    setGrokStatus(err.message || 'Unexpected error', 'error');
                } finally {
                    setGrokLoading(false);
                }
            });
        }

        // Export functionality
        document.getElementById('exportBtn').addEventListener('click', () => {
            const report = generateReport();
            downloadReport(report);
        });

        function generateReport() {
            let report = `# NYC Urban Ideas - Consolidated Report\n`;
            report += `Generated: ${new Date().toLocaleDateString()}\n\n`;
            report += `## Summary\n`;
            report += `- Total Ideas: ${graphData.nodes.length}\n`;
            report += `- Total Connections: ${graphData.edges.length}\n`;
            report += `- Identified Clusters: ${clusters.length}\n\n`;

            report += `## Actionable Clusters\n\n`;

            clusters.sort((a, b) => b.nodes.length - a.nodes.length).forEach(cluster => {
                report += `### ${cluster.name} (${cluster.nodes.length} supporters)\n\n`;
                report += `**Topic:** ${cluster.topic}\n\n`;
                report += `**Ideas:**\n`;
                cluster.nodes.forEach(node => {
                    report += `- @${node.username}: ${node.summary || 'No summary'}\n`;
                });
                report += `\n`;
            });

            report += `## All Ideas by Date\n\n`;
            graphData.nodes.sort((a, b) => new Date(b.date) - new Date(a.date)).forEach(node => {
                report += `- [${node.date}] @${node.username}: ${node.summary || 'No summary'}\n`;
            });

            return report;
        }

        function downloadReport(content) {
            const blob = new Blob([content], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `nyc-urban-ideas-report-${new Date().toISOString().split('T')[0]}.md`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Prompt modal functions
        function showPromptModal() {
            const topic = document.getElementById('grokPrompt')?.value || 'urban improvement ideas';
            const count = document.getElementById('grokCount')?.value || 10;

            const prompt = `Search X/Twitter for ${count} posts about: ${topic}

For each relevant post found, extract and format as CSV with these exact columns:
Username,Summary/Quote,Date,Link

Requirements:
- Username: Twitter handle without @ symbol
- Summary/Quote: A brief 1-2 sentence summary of what they're suggesting or advocating for
- Date: In YYYY-MM-DD format
- Link: Direct link to the tweet (https://x.com/username/status/...)

Output ONLY the CSV data, starting with the header row. No additional text or explanation.

Example output:
Username,Summary/Quote,Date,Link
BrentToderian,"Implement school streets - car-free blocks beside schools during drop-off/pick-up times.",2024-03-15,https://x.com/BrentToderian/status/123456789`;

            document.getElementById('promptText').value = prompt;
            document.getElementById('promptModal').style.display = 'flex';
        }

        function closePromptModal() {
            document.getElementById('promptModal').style.display = 'none';
        }

        function copyPromptToClipboard() {
            const promptText = document.getElementById('promptText');
            promptText.select();
            document.execCommand('copy');

            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = 'Copied!';
            setTimeout(() => btn.textContent = originalText, 2000);
        }

        // CSV upload handling
        function handleCSVUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const csv = e.target.result;
                    const rows = parseCSV(csv);

                    if (rows.length === 0) {
                        alert('No valid rows found in CSV');
                        return;
                    }

                    // Show preview and confirm
                    const confirmMsg = `Found ${rows.length} rows to import:\n\n` +
                        rows.slice(0, 3).map(r => `• @${r.Username}: ${(r['Summary/Quote'] || r.summary || '').substring(0, 50)}...`).join('\n') +
                        (rows.length > 3 ? `\n... and ${rows.length - 3} more` : '') +
                        `\n\nAdd to project "${currentProject}"?`;

                    if (confirm(confirmMsg)) {
                        addGrokResultsToProject(rows);
                    }
                } catch (err) {
                    console.error('CSV parse error:', err);
                    alert('Failed to parse CSV: ' + err.message);
                }
            };
            reader.readAsText(file);

            // Reset input so same file can be uploaded again
            event.target.value = '';
        }

        function parseCSV(csv) {
            const lines = csv.trim().split('\n');
            if (lines.length < 2) return [];

            // Parse header
            const header = parseCSVLine(lines[0]);
            const rows = [];

            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                const values = parseCSVLine(line);
                const row = {};

                header.forEach((col, idx) => {
                    row[col.trim()] = values[idx] || '';
                });

                // Validate required fields
                const username = row.Username || row.username || '';
                const summary = row['Summary/Quote'] || row.summary || row.Summary || '';

                if (username && summary) {
                    rows.push({
                        Username: username.replace('@', ''),
                        'Summary/Quote': summary,
                        Date: row.Date || row.date || '',
                        Link: row.Link || row.link || ''
                    });
                }
            }

            return rows;
        }

        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];

                if (char === '"') {
                    if (inQuotes && line[i + 1] === '"') {
                        current += '"';
                        i++;
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if (char === ',' && !inQuotes) {
                    result.push(current);
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current);

            return result;
        }

        // Close modal on outside click
        document.addEventListener('click', function(e) {
            const modal = document.getElementById('promptModal');
            if (e.target === modal) {
                closePromptModal();
            }
        });

        // Initialize
        loadData();
    </script>

    <!-- Prompt Modal -->
    <div id="promptModal" class="prompt-modal">
        <div class="prompt-modal-content">
            <div class="prompt-modal-header">
                <h3>Prompt for Grok</h3>
                <button class="prompt-modal-close" onclick="closePromptModal()">&times;</button>
            </div>
            <div class="prompt-modal-body">
                <p>Copy this prompt and paste it into <a href="https://grok.x.ai" target="_blank">grok.x.ai</a>. Then export the response as CSV and upload it.</p>
                <textarea id="promptText" class="prompt-textarea" readonly></textarea>
            </div>
            <div class="prompt-modal-footer">
                <button class="prompt-copy-btn" onclick="copyPromptToClipboard()">📋 Copy to Clipboard</button>
                <button class="prompt-close-btn" onclick="closePromptModal()">Close</button>
            </div>
        </div>
    </div>
</body>
</html>
