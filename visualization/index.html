<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CityVoice - AI-Powered Citizen Suggestion Clustering | xAI Hackathon</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0c10;
            color: #e6edf3;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .graph-panel {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        #graph {
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        #graph:active {
            cursor: grabbing;
        }

        /* Subtle grid background */
        .graph-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image:
                linear-gradient(rgba(255,255,255,0.02) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.02) 1px, transparent 1px);
            background-size: 50px 50px;
            pointer-events: none;
        }

        /* Node glow effects */
        .node circle {
            filter: drop-shadow(0 0 2px currentColor);
            transition: all 0.3s ease;
        }

        .node:hover circle {
            filter: drop-shadow(0 0 6px currentColor);
            transform: scale(1.2);
        }

        /* Pulse animation for high-consensus clusters */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .side-panel {
            width: 400px;
            background: #0d1117;
            border-left: 1px solid #21262d;
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            padding: 24px 20px;
            border-bottom: 1px solid #21262d;
        }

        .logo-row {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo-icon {
            font-size: 1.5rem;
        }

        .panel-header h1 {
            font-size: 1.25rem;
            font-weight: 600;
            color: #f0f6fc;
            margin-bottom: 0;
            letter-spacing: -0.02em;
        }

        .panel-header p {
            font-size: 0.8rem;
            color: #7d8590;
            margin-top: 4px;
        }

        .powered-by {
            font-size: 0.65rem;
            color: #484f58;
            margin-top: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
        }

        .tabs {
            display: flex;
            border-bottom: 1px solid #21262d;
            background: rgba(13, 17, 23, 0.5);
        }

        .tab {
            flex: 1;
            padding: 12px 8px;
            text-align: center;
            cursor: pointer;
            background: transparent;
            border: none;
            color: #6e7681;
            font-size: 0.8rem;
            font-weight: 500;
            transition: all 0.2s;
            border-bottom: 2px solid transparent;
            margin-bottom: -1px;
        }

        .tab:hover {
            color: #c9d1d9;
        }

        .tab.active {
            color: #e07a5f;
            border-bottom-color: #e07a5f;
            background: transparent;
        }

        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }

        .cluster-card {
            background: #161b22;
            border-radius: 10px;
            padding: 14px 16px;
            margin-bottom: 10px;
            border: 1px solid #21262d;
            transition: all 0.2s;
            cursor: pointer;
        }

        .cluster-card:hover {
            background: #21262d;
            border-color: #30363d;
        }

        .cluster-card.selected {
            border-color: #e07a5f;
            box-shadow: 0 0 20px rgba(224, 122, 95, 0.15);
        }

        .cluster-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .cluster-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .cluster-title {
            font-weight: 600;
            font-size: 1rem;
        }

        .cluster-count {
            font-size: 0.75rem;
            color: #8b949e;
            background: #30363d;
            padding: 2px 8px;
            border-radius: 10px;
            margin-left: auto;
        }

        .cluster-summary {
            font-size: 0.85rem;
            color: #8b949e;
            line-height: 1.5;
            margin-bottom: 10px;
        }

        .consensus-badge {
            display: inline-block;
            font-size: 0.7rem;
            padding: 3px 8px;
            border-radius: 10px;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }

        .consensus-badge.high {
            background: rgba(34, 197, 94, 0.2);
            color: #22c55e;
            border: 1px solid rgba(34, 197, 94, 0.3);
        }

        .consensus-badge.medium {
            background: rgba(249, 115, 22, 0.2);
            color: #f97316;
            border: 1px solid rgba(249, 115, 22, 0.3);
        }

        .consensus-badge.low {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        .cluster-action {
            font-size: 0.8rem;
            color: #ffa657;
            padding: 8px;
            background: rgba(255, 166, 87, 0.1);
            border-radius: 6px;
            margin-bottom: 10px;
            border-left: 3px solid #ffa657;
        }

        .cluster-items {
            display: none;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #30363d;
        }

        .cluster-card.expanded .cluster-items {
            display: block;
        }

        .item-mini {
            font-size: 0.8rem;
            color: #8b949e;
            padding: 8px;
            background: #161b22;
            border-radius: 6px;
            margin-bottom: 6px;
        }

        .item-mini .username {
            color: #58a6ff;
            font-weight: 500;
        }

        .node-detail {
            padding: 8px 12px 20px 12px;
        }

        .node-detail .summary {
            font-size: 0.95rem;
            line-height: 1.7;
            margin-bottom: 14px;
            color: #e6edf3;
            padding: 14px;
            padding-right: 36px;
            background: #161b22;
            border-radius: 8px;
            text-align: left;
            position: relative;
        }

        .tweet-link-icon {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #6e7681;
            text-decoration: none;
            font-size: 0.8rem;
            padding: 4px 6px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .tweet-link-icon:hover {
            color: #58a6ff;
            background: rgba(88, 166, 255, 0.15);
        }

        .detail-meta {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
            padding: 0 14px 16px 14px;
            border-bottom: 1px solid #21262d;
        }

        .detail-author {
            font-size: 0.85rem;
            color: #58a6ff;
            font-weight: 500;
            text-decoration: none;
        }

        .detail-author:hover {
            text-decoration: underline;
        }

        .detail-date {
            font-size: 0.75rem;
            color: #6e7681;
        }

        .node-clusters {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 16px;
        }

        .cluster-label-text {
            font-size: 0.7rem;
            color: #6e7681;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .node-cluster-tag {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 5px 10px;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .node-cluster-tag:hover {
            transform: translateY(-1px);
            filter: brightness(1.1);
        }

        .node-cluster-tag .cluster-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .detail-actions {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .node-detail .connections-header {
            font-size: 0.85rem;
            color: #8b949e;
            margin-bottom: 12px;
            margin-top: 24px;
            font-weight: 500;
            padding-bottom: 8px;
            border-bottom: 1px solid #21262d;
        }

        .connection-item {
            background: #161b22;
            padding: 12px 14px;
            border-radius: 8px;
            margin-bottom: 16px;
            border-left: 3px solid #e07a5f;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
        }

        .connection-item:hover {
            background: #21262d;
            border-left-width: 4px;
            transform: translateX(2px);
        }

        .connection-content {
            display: flex;
            align-items: flex-start;
            gap: 8px;
        }

        .connection-text-wrap {
            flex: 1;
        }

        .connection-item .reason {
            font-size: 0.75rem;
            color: #6e7681;
            font-style: italic;
            margin-top: 6px;
            padding-top: 6px;
            border-top: 1px solid #21262d;
        }

        .connection-item .connection-author {
            color: #58a6ff;
            font-weight: 500;
        }

        .connection-link-icon {
            color: #484f58;
            text-decoration: none;
            font-size: 0.75rem;
            padding: 2px;
            flex-shrink: 0;
        }

        .connection-link-icon:hover {
            color: #58a6ff;
        }

        .link-btn {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: transparent;
            color: #58a6ff;
            text-decoration: none;
            border-radius: 6px;
            font-size: 0.8rem;
            transition: all 0.2s;
            font-weight: 500;
            border: 1px solid #30363d;
        }

        .link-btn:hover {
            background: rgba(88, 166, 255, 0.1);
            border-color: #58a6ff;
        }

        .stats-bar {
            display: none;
            justify-content: space-around;
            padding: 16px 12px;
            background: linear-gradient(180deg, rgba(13, 17, 23, 0) 0%, rgba(13, 17, 23, 0.8) 100%);
            border-bottom: 1px solid #21262d;
        }

        .stat {
            text-align: center;
        }

        .stat-value {
            font-size: 1.4rem;
            font-weight: 700;
            color: #f0f6fc;
            font-family: 'JetBrains Mono', monospace;
        }

        .stat-label {
            font-size: 0.65rem;
            color: #6e7681;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 2px;
        }

        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 100;
        }

        .control-btn {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            border: 1px solid #30363d;
            background: rgba(33, 38, 45, 0.9);
            color: #8b949e;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.2s;
            backdrop-filter: blur(8px);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .control-btn:hover {
            background: rgba(48, 54, 61, 0.95);
            border-color: #484f58;
            color: #e6edf3;
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        .force-panel {
            position: absolute;
            top: 20px;
            left: 70px;
            background: rgba(22, 27, 34, 0.95);
            padding: 10px 16px;
            border-radius: 10px;
            border: 1px solid #30363d;
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 24px;
            backdrop-filter: blur(8px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .force-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .force-control label {
            font-size: 0.7rem;
            color: #8b949e;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            white-space: nowrap;
        }

        .force-control input[type="range"] {
            width: 80px;
            accent-color: #e07a5f;
            height: 4px;
        }

        .force-control span {
            font-size: 0.7rem;
            color: #6e7681;
            min-width: 40px;
            font-family: 'JetBrains Mono', monospace;
        }

        .legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(22, 27, 34, 0.95);
            padding: 12px 14px;
            border-radius: 10px;
            border: 1px solid #30363d;
            z-index: 100;
            backdrop-filter: blur(8px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .legend h4 {
            font-size: 0.65rem;
            color: #6e7681;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
            font-size: 0.8rem;
            cursor: pointer;
            padding: 5px 8px;
            border-radius: 6px;
            transition: all 0.2s;
            color: #c9d1d9;
        }

        .legend-item:hover {
            background: rgba(255, 123, 84, 0.1);
            color: #f0f6fc;
        }

        .legend-color {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .tooltip {
            position: absolute;
            background: rgba(22, 27, 34, 0.98);
            padding: 12px 16px;
            border-radius: 10px;
            border: 1px solid #30363d;
            font-size: 0.8rem;
            max-width: 320px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s;
            z-index: 1000;
            color: #c9d1d9;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            line-height: 1.5;
        }

        .tooltip.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .tooltip .username {
            color: #e07a5f;
            font-weight: 600;
        }

        .tooltip .tweet-link {
            display: inline-block;
            margin-top: 8px;
            padding: 4px 10px;
            background: rgba(88, 166, 255, 0.15);
            color: #58a6ff;
            border-radius: 4px;
            font-size: 0.75rem;
            text-decoration: none;
            pointer-events: auto;
        }

        .tooltip .tweet-link:hover {
            background: rgba(88, 166, 255, 0.25);
        }

        /* Cluster overlay labels - Google Maps style */
        .cluster-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
            transition: opacity 0.3s ease;
            overflow: visible;
        }

        .cluster-label {
            position: absolute;
            transform: translate(-50%, -50%);
            background: rgba(13, 17, 23, 0.9);
            color: #f0f6fc;
            padding: 8px 14px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            white-space: nowrap;
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            pointer-events: auto;
            cursor: pointer;
            transition: all 0.2s ease;
            touch-action: none;
        }

        .cluster-label:hover {
            background: rgba(33, 38, 45, 0.98);
            transform: translate(-50%, -50%) scale(1.05);
            border-color: rgba(255, 255, 255, 0.25);
        }

        .cluster-label.hovered {
            background: rgba(224, 122, 95, 0.9);
            border-color: rgba(255, 255, 255, 0.4);
            transform: translate(-50%, -50%) scale(1.08);
        }

        /* Overview mode dimming effect */
        .graph-panel.overview-mode::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(10, 12, 16, 0.3);
            pointer-events: none;
            z-index: 40;
            transition: opacity 0.3s ease;
        }

        .cluster-label .count {
            display: inline-block;
            background: rgba(255, 255, 255, 0.15);
            padding: 2px 6px;
            border-radius: 8px;
            margin-left: 6px;
            font-size: 0.65rem;
            font-weight: 500;
        }

        .cluster-label .dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 6px;
            vertical-align: middle;
        }

        /* Overlay toggle control */
        .overlay-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(22, 27, 34, 0.95);
            padding: 6px;
            border-radius: 8px;
            border: 1px solid #30363d;
            z-index: 100;
            display: flex;
            gap: 2px;
            backdrop-filter: blur(8px);
        }

        .overlay-btn {
            padding: 6px 10px;
            border: none;
            background: transparent;
            color: #6e7681;
            font-size: 0.7rem;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .overlay-btn:hover {
            color: #c9d1d9;
        }

        .overlay-btn.active {
            background: #30363d;
            color: #f0f6fc;
        }

        .export-section {
            padding: 12px 16px;
            border-top: 1px solid #21262d;
            background: rgba(13, 17, 23, 0.5);
        }

        .export-btn {
            width: 100%;
            padding: 10px 16px;
            background: linear-gradient(135deg, #e07a5f 0%, #c96a50 100%);
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(224, 122, 95, 0.25);
        }

        .export-btn:hover {
            background: linear-gradient(135deg, #c96a50 0%, #b05a42 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(224, 122, 95, 0.35);
        }

        .export-btn:active {
            transform: translateY(0);
        }

        .search-box {
            padding: 12px 16px;
            border-bottom: 1px solid #21262d;
        }

        .search-input {
            width: 100%;
            padding: 10px 14px;
            border-radius: 8px;
            border: 1px solid #30363d;
            background: #161b22;
            color: #e6edf3;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        .search-input:focus {
            outline: none;
            border-color: #e07a5f;
            background: #21262d;
            box-shadow: 0 0 0 3px rgba(224, 122, 95, 0.1);
        }

        .search-input::placeholder {
            color: #6e7681;
        }

        .actionable-list {
            padding: 0;
        }

        .actionable-header {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #30363d;
        }

        .actionable-header h3 {
            font-size: 1rem;
            color: #e6edf3;
            margin-bottom: 4px;
        }

        .actionable-header p {
            font-size: 0.8rem;
            color: #8b949e;
        }

        .actionable-item {
            background: #21262d;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            border: 1px solid #30363d;
            display: flex;
            gap: 15px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .actionable-item:hover {
            background: #282e36;
            transform: translateX(5px);
        }

        .actionable-rank {
            font-size: 1.5rem;
            font-weight: 700;
            color: #484f58;
            min-width: 40px;
        }

        .actionable-content {
            flex: 1;
        }

        .actionable-title-row {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 8px;
        }

        .actionable-item h4 {
            font-size: 0.95rem;
            margin: 0;
            color: #e6edf3;
        }

        .topic-tag {
            font-size: 0.7rem;
            padding: 2px 8px;
            border-radius: 10px;
            font-weight: 500;
        }

        .support-bar {
            height: 4px;
            background: #30363d;
            border-radius: 2px;
            margin-bottom: 6px;
            overflow: hidden;
        }

        .support-fill {
            height: 100%;
            border-radius: 2px;
            transition: width 0.5s ease-out;
        }

        .support-text {
            font-size: 0.75rem;
            color: #8b949e;
            margin-bottom: 8px;
        }

        .action-text {
            font-size: 0.85rem;
            color: #ffa657;
            margin-bottom: 8px;
            font-style: italic;
        }

        .actionable-item .description {
            font-size: 0.8rem;
            color: #8b949e;
            line-height: 1.5;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .grok-chat {
            display: flex;
            flex-direction: column;
            gap: 12px;
            height: 100%;
        }

        .grok-chat-history {
            flex: 1;
            background: #161b22;
            border: 1px solid #21262d;
            border-radius: 10px;
            padding: 12px;
            overflow-y: auto;
            min-height: 160px;
        }

        .grok-chat-hint {
            font-size: 0.8rem;
            color: #8b949e;
            text-align: center;
            padding: 10px;
        }

        .grok-chat-message {
            margin-bottom: 12px;
            padding: 10px 12px;
            border-radius: 10px;
            font-size: 0.85rem;
            line-height: 1.5;
            border: 1px solid #30363d;
        }

        .grok-chat-message.user {
            background: rgba(88, 166, 255, 0.08);
            border-color: rgba(88, 166, 255, 0.2);
        }

        .grok-chat-message.assistant {
            background: rgba(224, 122, 95, 0.08);
            border-color: rgba(224, 122, 95, 0.15);
        }

        .grok-chat-form {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .grok-chat-form textarea {
            width: 100%;
            border-radius: 8px;
            border: 1px solid #30363d;
            background: #0d1117;
            color: #e6edf3;
            padding: 10px 12px;
            resize: vertical;
            min-height: 70px;
        }

        .grok-chat-form textarea:focus {
            outline: none;
            border-color: #e07a5f;
            box-shadow: 0 0 0 3px rgba(224, 122, 95, 0.15);
        }

        .grok-form-grid {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 8px;
        }

        .grok-form-grid input {
            width: 100%;
            border-radius: 6px;
            border: 1px solid #30363d;
            background: #0d1117;
            color: #e6edf3;
            padding: 8px 10px;
            font-size: 0.8rem;
        }

        .grok-form-grid label {
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.4px;
            color: #6e7681;
        }

        .grok-form-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .grok-form-row > div {
            flex: 1 1 30%;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .grok-form-row label {
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.4px;
            color: #6e7681;
        }

        .grok-form-row input,
        .grok-form-row select {
            flex: 1;
            border-radius: 6px;
            border: 1px solid #30363d;
            background: #0d1117;
            color: #e6edf3;
            padding: 8px 10px;
        }

        .grok-send-btn {
            border: none;
            border-radius: 8px;
            background: linear-gradient(135deg, #e07a5f 0%, #c96a50 100%);
            color: #fff;
            padding: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.2s, transform 0.2s;
        }

        .grok-send-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .grok-status {
            font-size: 0.75rem;
            color: #8b949e;
            min-height: 18px;
        }

        .grok-result {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .grok-result-meta {
            font-size: 0.75rem;
            color: #8b949e;
        }

        .grok-row {
            border-radius: 8px;
            border: 1px solid #30363d;
            padding: 10px 12px;
            background: #0d1117;
            margin-bottom: 8px;
        }

        .grok-row-header {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            color: #8b949e;
            margin-bottom: 6px;
        }

        .grok-row-link {
            font-size: 0.75rem;
            display: inline-flex;
            gap: 6px;
            color: #58a6ff;
            text-decoration: none;
            margin-top: 6px;
        }

        .grok-row-link:hover {
            text-decoration: underline;
        }

        .grok-error {
            color: #ef4444;
        }

        .grok-raw {
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 10px;
            font-size: 0.75rem;
            overflow-x: auto;
        }

        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: #8b949e;
        }

        .empty-state p {
            font-size: 0.9rem;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #0d1117;
        }

        ::-webkit-scrollbar-thumb {
            background: #30363d;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #484f58;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="graph-panel">
            <svg id="graph"></svg>

            <div class="controls">
                <button class="control-btn" id="zoomIn" title="Zoom In">+</button>
                <button class="control-btn" id="zoomOut" title="Zoom Out">‚àí</button>
                <button class="control-btn" id="resetView" title="Reset View">‚åñ</button>
            </div>

            <div class="force-panel" id="forcePanel">
                <div class="force-control">
                    <label>Repulsion</label>
                    <input type="range" id="chargeSlider" min="-3000" max="-200" value="-1500">
                    <span id="chargeValue">-1500</span>
                </div>
                <div class="force-control">
                    <label>Distance</label>
                    <input type="range" id="distanceSlider" min="50" max="400" value="200">
                    <span id="distanceValue">200</span>
                </div>
                <div class="force-control">
                    <label>Collision</label>
                    <input type="range" id="collisionSlider" min="50" max="200" value="120">
                    <span id="collisionValue">120</span>
                </div>
            </div>

            <div class="legend" id="legend">
                <h4>Topics</h4>
            </div>

            <div class="cluster-overlay" id="clusterOverlay"></div>

            <div class="overlay-toggle" id="overlayToggle">
                <button class="overlay-btn active" data-mode="auto">Auto</button>
                <button class="overlay-btn" data-mode="always">Always</button>
                <button class="overlay-btn" data-mode="never">Never</button>
            </div>

            <div class="tooltip" id="tooltip"></div>
        </div>

        <div class="side-panel">
            <div class="panel-header">
                <div class="logo-row">
                    <span class="logo-icon">üèôÔ∏è</span>
                    <h1>CityVoice</h1>
                </div>
                <p>AI-powered citizen suggestion clustering</p>
                <div class="powered-by">Powered by xAI Grok</div>
            </div>

            <div class="stats-bar">
                <div class="stat">
                    <div class="stat-value" id="totalIdeas">0</div>
                    <div class="stat-label">Ideas</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="totalConnections">0</div>
                    <div class="stat-label">Connections</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="totalClusters">0</div>
                    <div class="stat-label">Clusters</div>
                </div>
            </div>

            <div class="search-box">
                <input type="text" class="search-input" id="searchInput" placeholder="Search ideas...">
            </div>

            <div class="tabs">
                <button class="tab active" data-tab="clusters">Clusters</button>
                <button class="tab" data-tab="actionable">Actionable</button>
                <button class="tab" data-tab="grok">Grok Search</button>
                <button class="tab" data-tab="detail">Detail</button>
            </div>

            <div class="panel-content">
                <div class="tab-content active" id="clusters-tab">
                    <div id="clusterList"></div>
                </div>

                <div class="tab-content" id="actionable-tab">
                    <div id="actionableList" class="actionable-list"></div>
                </div>

                <div class="tab-content" id="grok-tab">
                    <div class="grok-chat">
                        <div class="grok-chat-history" id="grokChatHistory">
                            <div class="grok-chat-hint">
                                Ask Grok to pull the latest city planning posts from X. Provide a location or topic and optional handle filters.
                            </div>
                        </div>
                        <form class="grok-chat-form" id="grokChatForm">
                            <textarea id="grokPrompt" placeholder="e.g., Recent protected bike lane proposals in Manhattan" required></textarea>
                            <div class="grok-form-row">
                                <div>
                                    <label for="grokCount">Posts</label>
                                    <input type="number" id="grokCount" min="1" max="25" value="10">
                                </div>
                                <div>
                                    <label for="grokFromDate">From</label>
                                    <input type="date" id="grokFromDate">
                                </div>
                                <div>
                                    <label for="grokToDate">To</label>
                                    <input type="date" id="grokToDate">
                                </div>
                            </div>
                            <div class="grok-form-grid">
                                <div>
                                    <label for="grokAllowed">Allowed handles</label>
                                    <input type="text" id="grokAllowed" placeholder="Comma-separated (optional)">
                                </div>
                                <div>
                                    <label for="grokExcluded">Exclude handles</label>
                                    <input type="text" id="grokExcluded" placeholder="@handles to skip">
                                </div>
                            </div>
                            <button type="submit" class="grok-send-btn" id="grokSendBtn">Send to Grok</button>
                        </form>
                        <div class="grok-status" id="grokStatus"></div>
                    </div>
                </div>

                <div class="tab-content" id="detail-tab">
                    <div id="nodeDetail" class="empty-state">
                        <p>Click on a node in the graph to see details</p>
                    </div>
                </div>
            </div>

            <div class="export-section">
                <button class="export-btn" id="exportBtn">Export Consolidated Report</button>
            </div>
        </div>
    </div>

    <script>
        // Graph data will be loaded from JSON
        let graphData = null;
        let enhancedClusters = null;
        let clusters = [];
        let simulation = null;
        let showLabels = true;
        let selectedCluster = null;
        let selectedNode = null;

        // Color palette for clusters - muted, sophisticated tones
        const clusterColors = {
            'Housing': '#e07a5f',      // Terracotta
            'Transit': '#81b29a',      // Sage
            'Sidewalks': '#7c98b3',    // Steel blue
            'Safety': '#c97c5d',       // Rust
            'Green Space': '#a8c686',  // Olive
            'Schools': '#b8a9c9',      // Dusty lavender
            'Other': '#8b949e'         // Gray
        };

        const fallbackColors = [
            '#e07a5f', '#81b29a', '#7c98b3', '#c97c5d', '#a8c686',
            '#b8a9c9', '#9ab3d5', '#d4a574', '#a3c4bc', '#c9b1d4'
        ];

        // Node dimension constants
        const NODE_FONT_SIZE = 11;
        const NODE_LINE_HEIGHT = 14;
        const NODE_PADDING_V = 8;
        const NODE_PADDING_H = 10;

        // Overlay mode: 'auto' | 'always' | 'never'
        let overlayMode = 'auto';

        // Tooltip hover state
        let tooltipTimeout = null;
        let isTooltipHovered = false;

        // Topic keywords for classification
        const topicKeywords = {
            'Housing': ['housing', 'home', 'apartment', 'ADU', 'dwelling', 'zoning', 'residential', 'units', 'building', 'dense', 'homes'],
            'Transit': ['bus', 'subway', 'transit', 'rail', 'train', 'metro', 'transport', 'commute', 'lane'],
            'Sidewalks': ['sidewalk', 'pedestrian', 'street', 'walk', 'crosswalk', 'curb', 'wider'],
            'Safety': ['safety', 'safe', 'police', 'officer', 'crime', 'security', 'enforcement', 'cops'],
            'Green Space': ['green', 'tree', 'park', 'garden', 'nature', 'permeable', 'flood'],
            'Bike Infrastructure': ['bike', 'bicycle', 'cycling'],
            'Schools': ['school', 'student', 'children', 'kids']
        };

        // Load and process data
        async function loadData() {
            try {
                // Load both data files in parallel
                const [graphResponse, clustersResponse] = await Promise.all([
                    fetch('/data/connections.json'),
                    fetch('/data/enhanced_clusters.json').catch(() => null)
                ]);

                graphData = await graphResponse.json();

                // Try to load enhanced clusters
                if (clustersResponse && clustersResponse.ok) {
                    enhancedClusters = await clustersResponse.json();
                    console.log('Loaded enhanced clusters:', enhancedClusters);
                }

                // Classify nodes by topic
                graphData.nodes.forEach(node => {
                    node.topics = classifyNode(node);
                    node.primaryTopic = node.topics[0] || 'Other';
                });

                // Use enhanced clusters if available, otherwise detect them
                if (enhancedClusters) {
                    useEnhancedClusters();
                } else {
                    detectClusters();
                }

                // Initialize visualization
                initGraph();
                updateStats();
                renderClusters();
                renderActionable();
                setupLegend();
                setupClusterOverlay();
                hookClusterLabelUpdates();
                setupOverlayToggle();

            } catch (error) {
                console.error('Error loading data:', error);
            }
        }

        function useEnhancedClusters() {
            // Build cluster assignments from enhanced clusters
            const nodeToCluster = new Map();
            let colorIdx = 0;

            clusters = enhancedClusters.clusters.map(ec => {
                const color = clusterColors[ec.topic] || fallbackColors[colorIdx++ % fallbackColors.length];

                ec.nodes.forEach(n => {
                    nodeToCluster.set(n.id, {
                        clusterId: ec.id,
                        color: color
                    });
                });

                return {
                    id: ec.id,
                    name: ec.name,
                    topic: ec.topic,
                    color: color,
                    nodes: ec.nodes.map(n => graphData.nodes.find(gn => gn.id === n.id) || n),
                    summary: ec.summary,
                    action: ec.action,
                    consensus: ec.consensus
                };
            });

            // Assign cluster info to nodes
            graphData.nodes.forEach(node => {
                const info = nodeToCluster.get(node.id);
                if (info) {
                    node.cluster = info.clusterId;
                    node.clusterColor = info.color;
                } else {
                    node.cluster = -1;
                    node.clusterColor = '#6b7280';
                }
            });
        }

        function classifyNode(node) {
            const text = (node.summary || '').toLowerCase();
            const topics = [];

            for (const [topic, keywords] of Object.entries(topicKeywords)) {
                if (keywords.some(kw => text.includes(kw))) {
                    topics.push(topic);
                }
            }

            return topics.length > 0 ? topics : ['Other'];
        }

        // Simple community detection using connected components and edge density
        function detectClusters() {
            const nodes = graphData.nodes;
            const edges = graphData.edges;

            // Build adjacency map with weights (connection count)
            const adjacency = new Map();
            nodes.forEach(n => adjacency.set(n.id, new Set()));

            edges.forEach(e => {
                adjacency.get(e.source_id).add(e.target_id);
                adjacency.get(e.target_id).add(e.source_id);
            });

            // Group by primary topic first, then subdivide by connectivity
            const topicGroups = new Map();
            nodes.forEach(node => {
                const topic = node.primaryTopic;
                if (!topicGroups.has(topic)) {
                    topicGroups.set(topic, []);
                }
                topicGroups.get(topic).push(node);
            });

            let clusterIndex = 0;
            clusters = [];

            topicGroups.forEach((topicNodes, topic) => {
                // For each topic group, find sub-clusters based on connectivity
                const subClusters = findSubClusters(topicNodes, adjacency);

                subClusters.forEach(subCluster => {
                    const color = clusterColors[clusterIndex % clusterColors.length];
                    const clusterObj = {
                        id: clusterIndex,
                        name: generateClusterName(subCluster, topic),
                        topic: topic,
                        color: color,
                        nodes: subCluster,
                        summary: generateClusterSummary(subCluster)
                    };

                    subCluster.forEach(node => {
                        node.cluster = clusterIndex;
                        node.clusterColor = color;
                    });

                    clusters.push(clusterObj);
                    clusterIndex++;
                });
            });
        }

        function findSubClusters(topicNodes, adjacency) {
            if (topicNodes.length <= 2) {
                return [topicNodes];
            }

            // Simple greedy clustering: group nodes that share edges
            const visited = new Set();
            const subClusters = [];

            topicNodes.forEach(node => {
                if (visited.has(node.id)) return;

                const cluster = [node];
                visited.add(node.id);

                const neighbors = adjacency.get(node.id);
                topicNodes.forEach(other => {
                    if (!visited.has(other.id) && neighbors.has(other.id)) {
                        cluster.push(other);
                        visited.add(other.id);
                    }
                });

                subClusters.push(cluster);
            });

            // Merge small clusters
            const merged = [];
            let currentMerge = [];

            subClusters.forEach(cluster => {
                if (cluster.length >= 2) {
                    merged.push(cluster);
                } else {
                    currentMerge = currentMerge.concat(cluster);
                    if (currentMerge.length >= 2) {
                        merged.push(currentMerge);
                        currentMerge = [];
                    }
                }
            });

            if (currentMerge.length > 0) {
                if (merged.length > 0) {
                    merged[merged.length - 1] = merged[merged.length - 1].concat(currentMerge);
                } else {
                    merged.push(currentMerge);
                }
            }

            return merged.length > 0 ? merged : [topicNodes];
        }

        function generateClusterName(nodes, topic) {
            // Extract key themes from summaries
            const allText = nodes.map(n => n.summary || '').join(' ').toLowerCase();

            // Find specific sub-themes
            if (allText.includes('staten island')) return `Staten Island ${topic}`;
            if (allText.includes('school')) return `School ${topic}`;
            if (allText.includes('wider') || allText.includes('width')) return `Sidewalk Width Reform`;
            if (allText.includes('bus lane')) return `Bus Lane Expansion`;
            if (allText.includes('dense') || allText.includes('density')) return `Dense Development`;
            if (allText.includes('pedestrian')) return `Pedestrianization`;

            return topic;
        }

        function generateClusterSummary(nodes) {
            // Create consolidated summary from node summaries
            const ideas = nodes.map(n => n.summary).filter(s => s && s.length > 10);
            if (ideas.length === 0) return 'Various related suggestions';

            if (ideas.length === 1) return ideas[0];

            // Find common themes
            return `${nodes.length} related suggestions: ${ideas[0].substring(0, 100)}...`;
        }

        function initGraph() {
            const svg = d3.select('#graph');
            const container = svg.node().parentElement;
            const width = container.clientWidth;
            const height = container.clientHeight;

            svg.attr('viewBox', [0, 0, width, height]);

            // Create container for zoom
            const g = svg.append('g').attr('class', 'graph-container');

            // Setup zoom
            const zoom = d3.zoom()
                .scaleExtent([0.2, 4])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                    // Update cluster overlay labels on zoom
                    if (typeof updateClusterLabelPositions === 'function') {
                        updateClusterLabelPositions();
                    }
                });

            svg.call(zoom);

            // Store zoom for global access
            window.svgZoom = zoom;
            window.svgElement = svg;
            window.graphContainer = g;
            window.graphWidth = width;
            window.graphHeight = height;

            // Setup controls
            d3.select('#zoomIn').on('click', () => svg.transition().call(zoom.scaleBy, 1.3));
            d3.select('#zoomOut').on('click', () => svg.transition().call(zoom.scaleBy, 0.7));
            d3.select('#resetView').on('click', () => svg.transition().call(zoom.transform, d3.zoomIdentity));

            // Force control sliders
            document.getElementById('chargeSlider').addEventListener('input', (e) => {
                forceParams.charge = parseInt(e.target.value);
                document.getElementById('chargeValue').textContent = e.target.value;
                window.updateForces();
            });
            document.getElementById('distanceSlider').addEventListener('input', (e) => {
                forceParams.linkDistance = parseInt(e.target.value);
                document.getElementById('distanceValue').textContent = e.target.value;
                window.updateForces();
            });
            document.getElementById('collisionSlider').addEventListener('input', (e) => {
                forceParams.collisionRadius = parseInt(e.target.value);
                document.getElementById('collisionValue').textContent = e.target.value;
                window.updateForces();
            });

            // Prepare edge data with node references
            const nodeMap = new Map(graphData.nodes.map(n => [n.id, n]));
            const links = graphData.edges.map(e => ({
                source: nodeMap.get(e.source_id),
                target: nodeMap.get(e.target_id),
                reason: e.reason
            }));

            // Force parameters (adjustable)
            let forceParams = {
                charge: -1500,
                linkDistance: 200,
                linkStrength: 0.2,
                collisionRadius: 120
            };

            // Create force simulation
            simulation = d3.forceSimulation(graphData.nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(forceParams.linkDistance).strength(forceParams.linkStrength))
                .force('charge', d3.forceManyBody().strength(forceParams.charge))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(forceParams.collisionRadius));

            // Store for later access
            window.simulation = simulation;
            window.forceParams = forceParams;
            window.updateForces = function() {
                simulation
                    .force('charge', d3.forceManyBody().strength(forceParams.charge))
                    .force('link').distance(forceParams.linkDistance).strength(forceParams.linkStrength);
                simulation.force('collision').radius(forceParams.collisionRadius);
                simulation.alpha(0.5).restart();
            };

            // Draw edges
            const link = g.append('g')
                .attr('class', 'links')
                .selectAll('line')
                .data(links)
                .enter().append('line')
                .attr('stroke', '#4a5568')
                .attr('stroke-opacity', 0.6)
                .attr('stroke-width', 1.5);

            // Draw nodes
            const node = g.append('g')
                .attr('class', 'nodes')
                .selectAll('g')
                .data(graphData.nodes)
                .enter().append('g')
                .attr('class', 'node')
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));

            // Node labels - show summary text, truncated
            // Using global constants: NODE_FONT_SIZE, NODE_LINE_HEIGHT, NODE_PADDING_V, NODE_PADDING_H
            const fontSize = NODE_FONT_SIZE;
            const lineHeight = NODE_LINE_HEIGHT;
            const paddingV = NODE_PADDING_V;
            const paddingH = NODE_PADDING_H;

            const nodeText = node.append('text')
                .attr('class', 'node-label')
                .attr('x', paddingH)
                .attr('fill', '#e6edf3')
                .attr('font-size', `${fontSize}px`)
                .style('pointer-events', 'none')
                .each(function(d) {
                    const text = d3.select(this);
                    const summary = d.summary || 'No summary';
                    const maxChars = 30;

                    // Split into lines
                    const words = summary.split(' ');
                    let lines = [];
                    let currentLine = '';

                    words.forEach(word => {
                        if ((currentLine + ' ' + word).trim().length <= maxChars) {
                            currentLine = (currentLine + ' ' + word).trim();
                        } else {
                            if (currentLine) lines.push(currentLine);
                            currentLine = word;
                        }
                    });
                    if (currentLine) lines.push(currentLine);

                    // Limit to 3 lines, add ellipsis if needed
                    if (lines.length > 3) {
                        lines = lines.slice(0, 3);
                        lines[2] = lines[2].substring(0, 26) + '...';
                    }

                    d.lineCount = lines.length;
                    d.maxLineWidth = Math.max(...lines.map(l => l.length)) * 6.5;

                    // Calculate centered y position
                    // Box height: paddingV + (lineCount * lineHeight) + paddingV - (lineHeight - fontSize)
                    // First baseline should be at: paddingV + fontSize (roughly)
                    const boxHeight = paddingV * 2 + d.lineCount * lineHeight - (lineHeight - fontSize);
                    const firstLineY = paddingV + fontSize - 2; // -2 for visual baseline adjustment

                    text.attr('y', firstLineY);

                    lines.forEach((line, i) => {
                        text.append('tspan')
                            .attr('x', paddingH)
                            .attr('dy', i === 0 ? 0 : lineHeight)
                            .text(line);
                    });
                });

            // Add rounded rectangle background behind text
            const getNodeHeight = (d) => paddingV * 2 + (d.lineCount || 2) * lineHeight - (lineHeight - fontSize);

            const getNodeWidth = (d) => Math.max(d.maxLineWidth + paddingH * 2, 120);

            node.insert('rect', 'text')
                .attr('class', 'node-bg')
                .attr('rx', 6)
                .attr('ry', 6)
                .attr('fill', '#21262d')
                .attr('stroke', d => d.clusterColor || '#81b29a')
                .attr('stroke-width', 1)
                .attr('fill-opacity', 1)
                .attr('stroke-opacity', 1)
                .attr('width', d => getNodeWidth(d))
                .attr('height', d => getNodeHeight(d))
                .attr('x', 0)
                .attr('y', 0)
                .style('cursor', 'pointer')
                .on('mouseover', handleMouseOver)
                .on('mouseout', handleMouseOut)
                .on('click', handleNodeClick);

            // Update positions on tick - edges connect to center of nodes
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x + getNodeWidth(d.source) / 2)
                    .attr('y1', d => d.source.y + getNodeHeight(d.source) / 2)
                    .attr('x2', d => d.target.x + getNodeWidth(d.target) / 2)
                    .attr('y2', d => d.target.y + getNodeHeight(d.target) / 2);

                node.attr('transform', d => `translate(${d.x},${d.y})`);
            });

            function adjacencyCount(id) {
                return graphData.edges.filter(e => e.source_id === id || e.target_id === id).length;
            }

            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
        }

        // Node dimension helpers
        function calcNodeWidth(n) {
            return Math.max((n.maxLineWidth || 100) + NODE_PADDING_H * 2, 120);
        }

        function calcNodeHeight(n) {
            return NODE_PADDING_V * 2 + (n.lineCount || 2) * NODE_LINE_HEIGHT - (NODE_LINE_HEIGHT - NODE_FONT_SIZE);
        }

        // Pan and zoom to show specific nodes
        function panToNodes(nodeIds, padding = 100) {
            if (!window.svgZoom || !nodeIds || nodeIds.length === 0) return;

            const targetNodes = graphData.nodes.filter(n => nodeIds.includes(n.id));
            if (targetNodes.length === 0) return;

            // Calculate bounding box of target nodes
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            targetNodes.forEach(n => {
                const nodeWidth = calcNodeWidth(n);
                const nodeHeight = calcNodeHeight(n);
                minX = Math.min(minX, n.x);
                maxX = Math.max(maxX, n.x + nodeWidth);
                minY = Math.min(minY, n.y);
                maxY = Math.max(maxY, n.y + nodeHeight);
            });

            // Add padding
            minX -= padding;
            maxX += padding;
            minY -= padding;
            maxY += padding;

            // Calculate zoom and translation
            const boxWidth = maxX - minX;
            const boxHeight = maxY - minY;
            const scale = Math.min(
                window.graphWidth / boxWidth,
                window.graphHeight / boxHeight,
                2 // Max zoom
            ) * 0.9;

            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;

            const transform = d3.zoomIdentity
                .translate(window.graphWidth / 2, window.graphHeight / 2)
                .scale(scale)
                .translate(-centerX, -centerY);

            window.svgElement
                .transition()
                .duration(750)
                .ease(d3.easeCubicInOut)
                .call(window.svgZoom.transform, transform);
        }

        // Pan to a single node
        function panToNode(nodeId) {
            panToNodes([nodeId], 200);
        }

        function handleMouseOver(event, d) {
            // Clear any pending hide timeout
            if (tooltipTimeout) clearTimeout(tooltipTimeout);

            const tooltip = d3.select('#tooltip');
            const hasLink = d.link && d.link.startsWith('http');
            tooltip
                .html(`
                    <div style="margin-bottom: 8px; line-height: 1.4;">${d.summary || 'No summary'}</div>
                    <span class="username">${d.username}</span> ¬∑ ${d.date || ''}
                    ${hasLink ? `<br><a href="${d.link}" target="_blank" class="tweet-link" onclick="event.stopPropagation();">View Tweet ‚Üí</a>` : ''}
                `)
                .style('left', (event.pageX + 15) + 'px')
                .style('top', (event.pageY - 10) + 'px')
                .classed('visible', true);

            // Highlight connected nodes
            const connected = new Set();
            graphData.edges.forEach(e => {
                if (e.source_id === d.id) connected.add(e.target_id);
                if (e.target_id === d.id) connected.add(e.source_id);
            });

            d3.selectAll('.node-bg')
                .attr('stroke-width', n => n.id === d.id || connected.has(n.id) ? 2 : 1)
                .attr('opacity', n => n.id === d.id || connected.has(n.id) ? 1 : 0.4);
            d3.selectAll('.node-label')
                .attr('opacity', n => n.id === d.id || connected.has(n.id) ? 1 : 0.3);

            d3.selectAll('.links line')
                .attr('stroke', l =>
                    (l.source.id === d.id || l.target.id === d.id) ? '#e07a5f' : '#4a5568'
                )
                .attr('stroke-opacity', l =>
                    (l.source.id === d.id || l.target.id === d.id) ? 1 : 0.2
                )
                .attr('stroke-width', l =>
                    (l.source.id === d.id || l.target.id === d.id) ? 2 : 1
                );
        }

        function handleMouseOut() {
            // Delay hiding tooltip to allow clicking link
            tooltipTimeout = setTimeout(() => {
                if (!isTooltipHovered) {
                    d3.select('#tooltip').classed('visible', false);
                    d3.selectAll('.node-bg')
                        .attr('stroke-width', 1)
                        .attr('opacity', 1);
                    d3.selectAll('.node-label').attr('opacity', 1);
                    d3.selectAll('.links line')
                        .attr('stroke', '#4a5568')
                        .attr('stroke-opacity', 0.6)
                        .attr('stroke-width', 1.5);
                }
            }, 150);
        }

        // Setup tooltip hover detection
        document.getElementById('tooltip').addEventListener('mouseenter', () => {
            isTooltipHovered = true;
            if (tooltipTimeout) clearTimeout(tooltipTimeout);
        });

        document.getElementById('tooltip').addEventListener('mouseleave', () => {
            isTooltipHovered = false;
            handleMouseOut();
        });

        function handleNodeClick(event, d, shouldPan = true) {
            selectedNode = d;
            showNodeDetail(d);

            // Pan to the node
            if (shouldPan && d.id !== undefined) {
                panToNode(d.id);
            }

            // Switch to detail tab
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelector('[data-tab="detail"]').classList.add('active');
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById('detail-tab').classList.add('active');
        }

        function showNodeDetail(node) {
            const connections = graphData.edges
                .filter(e => e.source_id === node.id || e.target_id === node.id)
                .map(e => {
                    const otherId = e.source_id === node.id ? e.target_id : e.source_id;
                    const other = graphData.nodes.find(n => n.id === otherId);
                    return { node: other, reason: e.reason };
                });

            // Find clusters this node belongs to
            const nodeClusters = clusters.filter(c =>
                c.nodes.some(n => n.id === node.id)
            );

            const twitterHandle = node.username.replace('@', '');
            const hasLink = node.link && node.link.startsWith('http');

            const detailHtml = `
                <div class="node-detail">
                    <div class="summary">
                        ${node.summary || 'No summary available'}
                        ${hasLink ? `<a href="${node.link}" target="_blank" class="tweet-link-icon" title="View original tweet">‚Üó</a>` : ''}
                    </div>
                    <div class="detail-meta">
                        <a href="https://twitter.com/${twitterHandle}" target="_blank" class="detail-author">${node.username}</a>
                        <span class="detail-date">${node.date}</span>
                    </div>
                    ${nodeClusters.length > 0 ? `
                        <div class="node-clusters">
                            <span class="cluster-label-text">Cluster:</span>
                            ${nodeClusters.map(c => `
                                <span class="node-cluster-tag" data-cluster-id="${c.id}" style="background: ${c.color}20; color: ${c.color}; border: 1px solid ${c.color}40;">
                                    <span class="cluster-dot" style="background: ${c.color}"></span>
                                    ${c.name}
                                </span>
                            `).join('')}
                        </div>
                    ` : ''}

                    <div class="connections-header" style="margin-top: 20px;">
                        ${connections.length} Connected Ideas
                    </div>
                    ${connections.map(c => {
                        const cHandle = c.node.username.replace('@', '');
                        const cHasLink = c.node.link && c.node.link.startsWith('http');
                        return `
                        <div class="connection-item clickable-connection" data-node-id="${c.node.id}">
                            <div class="connection-content">
                                <div class="connection-text-wrap">
                                    ${c.node.summary || 'No summary'} ‚Äî <a href="https://twitter.com/${cHandle}" target="_blank" class="connection-author" onclick="event.stopPropagation();">${c.node.username}</a>
                                </div>
                                ${cHasLink ? `<a href="${c.node.link}" target="_blank" class="connection-link-icon" onclick="event.stopPropagation();" title="View original tweet">‚Üó</a>` : ''}
                            </div>
                            <div class="reason">${c.reason}</div>
                        </div>
                    `}).join('')}
                </div>
            `;

            document.getElementById('nodeDetail').innerHTML = detailHtml;

            // Scroll detail panel to top
            document.querySelector('.panel-content').scrollTop = 0;

            // Add click handlers to cluster tags
            document.querySelectorAll('.node-cluster-tag').forEach(tag => {
                tag.addEventListener('click', () => {
                    const clusterId = parseInt(tag.dataset.clusterId);
                    highlightCluster(clusterId);
                    showClusterInSidebar(clusterId);
                });
            });

            // Add click handlers to connections
            document.querySelectorAll('.clickable-connection').forEach(item => {
                item.addEventListener('click', () => {
                    const nodeId = parseInt(item.dataset.nodeId);
                    const targetNode = graphData.nodes.find(n => n.id === nodeId);
                    if (targetNode) {
                        panToNode(nodeId);
                        showNodeDetail(targetNode);
                        // Highlight the node briefly
                        d3.selectAll('.node-bg')
                            .attr('stroke-width', n => n.id === nodeId ? 2 : 1)
                            .attr('opacity', n => n.id === nodeId ? 1 : 0.5);
                        setTimeout(() => {
                            d3.selectAll('.node-bg')
                                .attr('stroke-width', 1)
                                .attr('opacity', 1);
                        }, 2000);
                    }
                });
            });
        }

        function updateStats() {
            document.getElementById('totalIdeas').textContent = graphData.nodes.length;
            document.getElementById('totalConnections').textContent = graphData.edges.length;
            document.getElementById('totalClusters').textContent = clusters.length;
        }

        function renderClusters() {
            const container = document.getElementById('clusterList');

            // Sort by node count descending
            const sortedClusters = [...clusters].sort((a, b) => b.nodes.length - a.nodes.length);

            container.innerHTML = sortedClusters.map(cluster => `
                <div class="cluster-card" data-cluster="${cluster.id}">
                    <div class="cluster-header">
                        <div class="cluster-color" style="background: ${cluster.color}"></div>
                        <div class="cluster-title">${cluster.name}</div>
                        <div class="cluster-count">${cluster.nodes.length} ${cluster.nodes.length === 1 ? 'voice' : 'voices'}</div>
                    </div>
                    ${cluster.consensus ? `
                        <div class="consensus-badge ${cluster.consensus.toLowerCase()}">
                            ${cluster.consensus} Consensus
                        </div>
                    ` : ''}
                    <div class="cluster-summary">${cluster.summary}</div>
                    ${cluster.action ? `
                        <div class="cluster-action">
                            <strong>Action:</strong> ${cluster.action}
                        </div>
                    ` : ''}
                    <div class="cluster-items">
                        ${cluster.nodes.map(n => `
                            <div class="item-mini" data-node-id="${n.id}">
                                ${(n.summary || '').substring(0, 100)}${(n.summary || '').length > 100 ? '...' : ''} <span class="username">‚Äî ${n.username}</span>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `).join('');

            // Add click handlers
            container.querySelectorAll('.cluster-card').forEach(card => {
                card.addEventListener('click', (e) => {
                    // Don't toggle if clicking on an item
                    if (e.target.closest('.item-mini')) {
                        const nodeId = parseInt(e.target.closest('.item-mini').dataset.nodeId);
                        const node = graphData.nodes.find(n => n.id === nodeId);
                        if (node) {
                            handleNodeClick(null, node);
                        }
                        return;
                    }
                    const clusterId = parseInt(card.dataset.cluster);
                    card.classList.toggle('expanded');
                    highlightCluster(clusterId);
                });

                // Hover highlighting
                card.addEventListener('mouseenter', () => {
                    const clusterId = parseInt(card.dataset.cluster);
                    highlightClusterNodes(clusterId, true);
                });

                card.addEventListener('mouseleave', () => {
                    const clusterId = parseInt(card.dataset.cluster);
                    highlightClusterNodes(clusterId, false);
                });
            });
        }

        // Show cluster in sidebar - switch tab, scroll to card, highlight it
        function showClusterInSidebar(clusterId) {
            // Switch to Clusters tab
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelector('[data-tab="clusters"]').classList.add('active');
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById('clusters-tab').classList.add('active');

            // Find and highlight the cluster card
            const card = document.querySelector(`.cluster-card[data-cluster="${clusterId}"]`);
            if (card) {
                // Remove selected from other cards
                document.querySelectorAll('.cluster-card').forEach(c => c.classList.remove('selected'));

                // Select and expand this card
                card.classList.add('selected', 'expanded');

                // Scroll into view
                card.scrollIntoView({ behavior: 'smooth', block: 'center' });

                // Remove highlight after a delay
                setTimeout(() => {
                    card.classList.remove('selected');
                }, 3000);
            }
        }

        function highlightCluster(clusterId, shouldPan = true) {
            const cluster = clusters.find(c => c.id === clusterId);
            if (!cluster) return;

            const clusterNodeIds = new Set(cluster.nodes.map(n => n.id));

            // Pan to the cluster nodes
            if (shouldPan) {
                panToNodes([...clusterNodeIds]);
            }

            d3.selectAll('.node-bg')
                .attr('stroke-width', n => clusterNodeIds.has(n.id) ? 2 : 1)
                .attr('opacity', n => clusterNodeIds.has(n.id) ? 1 : 0.4);
            d3.selectAll('.node-label')
                .attr('opacity', n => clusterNodeIds.has(n.id) ? 1 : 0.2);

            d3.selectAll('.links line')
                .attr('stroke', l =>
                    clusterNodeIds.has(l.source.id) && clusterNodeIds.has(l.target.id) ? '#e07a5f' : '#4a5568'
                )
                .attr('stroke-opacity', l =>
                    clusterNodeIds.has(l.source.id) && clusterNodeIds.has(l.target.id) ? 1 : 0.15
                )
                .attr('stroke-width', l =>
                    clusterNodeIds.has(l.source.id) && clusterNodeIds.has(l.target.id) ? 2 : 1
                );

            // Reset highlighting after delay (but keep pan position)
            setTimeout(() => {
                d3.selectAll('.node-bg')
                    .attr('stroke-width', 1)
                    .attr('opacity', 1);
                d3.selectAll('.node-label').attr('opacity', 1);
                d3.selectAll('.links line')
                    .attr('stroke', '#4a5568')
                    .attr('stroke-opacity', 0.6)
                    .attr('stroke-width', 1.5);
            }, 3000);
        }

        function renderActionable() {
            const container = document.getElementById('actionableList');

            // Generate actionable items from clusters, sorted by support
            const actionable = clusters
                .filter(c => c.nodes.length > 0)
                .sort((a, b) => b.nodes.length - a.nodes.length)
                .map((cluster, idx) => ({
                    rank: idx + 1,
                    title: cluster.name,
                    topic: cluster.topic,
                    support: cluster.nodes.length,
                    consensus: cluster.consensus || 'Medium',
                    action: cluster.action || `Review ${cluster.nodes.length} suggestions about ${cluster.topic.toLowerCase()}`,
                    description: consolidateIdeas(cluster.nodes),
                    color: cluster.color,
                    nodes: cluster.nodes
                }));

            container.innerHTML = `
                <div class="actionable-header">
                    <h3>Priority Actions for City Officials</h3>
                    <p>Ranked by citizen support level</p>
                </div>
                ${actionable.map(item => `
                    <div class="actionable-item" data-cluster-id="${clusters.find(c => c.name === item.title)?.id}">
                        <div class="actionable-rank">#${item.rank}</div>
                        <div class="actionable-content">
                            <div class="actionable-title-row">
                                <h4 style="border-left: 3px solid ${item.color}; padding-left: 10px;">${item.title}</h4>
                                <span class="topic-tag" style="background: ${item.color}20; color: ${item.color}; border: 1px solid ${item.color}40;">${item.topic}</span>
                            </div>
                            <div class="support-bar">
                                <div class="support-fill" style="width: ${Math.min(100, item.support * 12)}%; background: ${item.color};"></div>
                            </div>
                            <div class="support-text">${item.support} citizen${item.support === 1 ? '' : 's'} ‚Ä¢ ${item.consensus} consensus</div>
                            <div class="action-text">${item.action}</div>
                            <div class="description">${item.description}</div>
                        </div>
                    </div>
                `).join('')}
            `;

            // Add click handlers to highlight clusters
            container.querySelectorAll('.actionable-item').forEach(item => {
                item.addEventListener('click', () => {
                    const clusterId = parseInt(item.dataset.clusterId);
                    if (!isNaN(clusterId)) {
                        highlightCluster(clusterId);
                    }
                });
            });
        }

        function consolidateIdeas(nodes) {
            const summaries = nodes.map(n => n.summary).filter(s => s && s.length > 10);
            if (summaries.length === 0) return 'Various related urban improvement suggestions.';

            if (summaries.length === 1) return summaries[0];

            // Create bullet points
            return summaries.slice(0, 3).map(s => `‚Ä¢ ${s.substring(0, 150)}${s.length > 150 ? '...' : ''}`).join('<br>');
        }

        function setupLegend() {
            const legend = document.getElementById('legend');
            const topics = [...new Set(graphData.nodes.map(n => n.primaryTopic))];

            topics.forEach((topic) => {
                const color = clusterColors[topic] || fallbackColors[0];
                const count = graphData.nodes.filter(n => n.primaryTopic === topic).length;
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.innerHTML = `
                    <div class="legend-color" style="background: ${color}"></div>
                    <span>${topic}</span>
                    <span style="color: #666; font-size: 0.75rem; margin-left: auto;">${count}</span>
                `;
                item.addEventListener('click', () => highlightTopic(topic));
                legend.appendChild(item);
            });
        }

        // Cluster overlay labels (Google Maps style)
        let clusterLabels = [];
        let currentZoomScale = 1;

        function setupClusterOverlay() {
            const overlay = document.getElementById('clusterOverlay');
            overlay.innerHTML = '';
            clusterLabels = [];

            // Create a label for each cluster with 2+ nodes
            clusters.filter(c => c.nodes.length >= 2).forEach(cluster => {
                const label = document.createElement('div');
                label.className = 'cluster-label';
                label.innerHTML = `
                    <span class="dot" style="background: ${cluster.color}"></span>
                    ${cluster.name}
                    <span class="count">${cluster.nodes.length}</span>
                `;

                // Click to zoom to cluster and show in sidebar
                label.addEventListener('click', () => {
                    highlightCluster(cluster.id);
                    showClusterInSidebar(cluster.id);
                });

                // Hover to highlight cluster nodes
                label.addEventListener('mouseenter', () => {
                    highlightClusterNodes(cluster.id, true);
                });
                label.addEventListener('mouseleave', () => {
                    highlightClusterNodes(cluster.id, false);
                });

                overlay.appendChild(label);
                clusterLabels.push({ element: label, cluster: cluster });
            });

            updateClusterLabelPositions();
        }

        function getClusterCentroid(cluster) {
            // Get actual node objects from graphData (they have x/y from simulation)
            const nodes = cluster.nodes
                .map(n => graphData.nodes.find(gn => gn.id === n.id))
                .filter(n => n && n.x !== undefined && n.y !== undefined);

            if (nodes.length === 0) {
                // Fallback to center of screen if no positioned nodes
                return { x: window.graphWidth / 2, y: window.graphHeight / 2 };
            }

            const sumX = nodes.reduce((sum, n) => sum + n.x + calcNodeWidth(n) / 2, 0);
            const sumY = nodes.reduce((sum, n) => sum + n.y + calcNodeHeight(n) / 2, 0);
            return {
                x: sumX / nodes.length,
                y: sumY / nodes.length
            };
        }

        function updateClusterLabelPositions() {
            if (!window.svgElement) return;

            const transform = d3.zoomTransform(window.svgElement.node());
            currentZoomScale = transform.k;

            // Determine visibility based on mode
            const overlay = document.getElementById('clusterOverlay');
            const graphPanel = document.querySelector('.graph-panel');
            let showOverlay = false;
            if (overlayMode === 'always') {
                showOverlay = true;
            } else if (overlayMode === 'never') {
                showOverlay = false;
            } else { // auto
                showOverlay = currentZoomScale < 0.7;
            }
            overlay.style.opacity = showOverlay ? 1 : 0;
            // Keep overlay pointer-events: none so panning works
            // Individual labels have pointer-events: auto via CSS

            // Toggle overview mode visual effect
            if (showOverlay) {
                graphPanel.classList.add('overview-mode');
            } else {
                graphPanel.classList.remove('overview-mode');
            }

            clusterLabels.forEach(({ element, cluster }) => {
                const centroid = getClusterCentroid(cluster);
                // Apply the same transform as the graph
                const screenX = centroid.x * transform.k + transform.x;
                const screenY = centroid.y * transform.k + transform.y;
                element.style.left = `${screenX}px`;
                element.style.top = `${screenY}px`;
            });
        }

        // Hook into simulation tick to update label positions
        function hookClusterLabelUpdates() {
            if (window.simulation) {
                const originalTick = window.simulation.on('tick');
                window.simulation.on('tick', () => {
                    if (originalTick) originalTick();
                    updateClusterLabelPositions();
                });
            }
        }

        // Setup overlay toggle buttons
        function setupOverlayToggle() {
            document.querySelectorAll('.overlay-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.overlay-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    overlayMode = btn.dataset.mode;
                    updateClusterLabelPositions();
                });
            });

            // Fix scroll passthrough - forward wheel events from overlay to SVG
            const overlay = document.getElementById('clusterOverlay');
            overlay.addEventListener('wheel', (e) => {
                e.preventDefault();
                // Forward wheel event to SVG for zoom
                const svgNode = window.svgElement?.node();
                if (svgNode) {
                    const wheelEvent = new WheelEvent('wheel', {
                        deltaX: e.deltaX,
                        deltaY: e.deltaY,
                        deltaMode: e.deltaMode,
                        clientX: e.clientX,
                        clientY: e.clientY,
                        screenX: e.screenX,
                        screenY: e.screenY,
                        bubbles: true,
                        cancelable: true
                    });
                    svgNode.dispatchEvent(wheelEvent);
                }
            }, { passive: false });
        }

        // Highlight nodes in a cluster (for hover on cluster labels)
        function highlightClusterNodes(clusterId, highlight) {
            const cluster = clusters.find(c => c.id === clusterId);
            if (!cluster) return;

            const clusterNodeIds = new Set(cluster.nodes.map(n => n.id));

            if (highlight) {
                // Highlight this cluster's nodes
                d3.selectAll('.node-bg')
                    .attr('stroke-width', n => clusterNodeIds.has(n.id) ? 2 : 1)
                    .attr('opacity', n => clusterNodeIds.has(n.id) ? 1 : 0.3);
                d3.selectAll('.node-label')
                    .attr('opacity', n => clusterNodeIds.has(n.id) ? 1 : 0.15);

                d3.selectAll('.links line')
                    .attr('stroke', l =>
                        clusterNodeIds.has(l.source.id) && clusterNodeIds.has(l.target.id) ? cluster.color : '#4a5568'
                    )
                    .attr('stroke-opacity', l =>
                        clusterNodeIds.has(l.source.id) && clusterNodeIds.has(l.target.id) ? 1 : 0.1
                    )
                    .attr('stroke-width', l =>
                        clusterNodeIds.has(l.source.id) && clusterNodeIds.has(l.target.id) ? 2.5 : 1
                    );

                // Also highlight the label
                const labelEl = clusterLabels.find(cl => cl.cluster.id === clusterId)?.element;
                if (labelEl) labelEl.classList.add('hovered');
            } else {
                // Reset highlights
                d3.selectAll('.node-bg')
                    .attr('stroke-width', 1)
                    .attr('opacity', 1);
                d3.selectAll('.node-label').attr('opacity', 1);
                d3.selectAll('.links line')
                    .attr('stroke', '#4a5568')
                    .attr('stroke-opacity', 0.6)
                    .attr('stroke-width', 1.5);

                // Remove highlight from label
                const labelEl = clusterLabels.find(cl => cl.cluster.id === clusterId)?.element;
                if (labelEl) labelEl.classList.remove('hovered');
            }
        }

        function highlightTopic(topic) {
            // Collect node IDs for this topic
            const topicNodeIds = graphData.nodes
                .filter(n => n.primaryTopic === topic)
                .map(n => n.id);

            // Pan to show all nodes of this topic
            if (topicNodeIds.length > 0) {
                panToNodes(topicNodeIds);
            }

            d3.selectAll('.node-bg')
                .attr('stroke-width', n => n.primaryTopic === topic ? 2 : 1)
                .attr('opacity', n => n.primaryTopic === topic ? 1 : 0.4);
            d3.selectAll('.node-label')
                .attr('opacity', n => n.primaryTopic === topic ? 1 : 0.2);

            setTimeout(() => {
                d3.selectAll('.node-bg')
                    .attr('stroke-width', 1)
                    .attr('opacity', 1);
                d3.selectAll('.node-label').attr('opacity', 1);
            }, 2000);
        }

        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');

                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                document.getElementById(`${tab.dataset.tab}-tab`).classList.add('active');
            });
        });

        // Search functionality
        document.getElementById('searchInput').addEventListener('input', (e) => {
            const query = e.target.value.toLowerCase();

            if (!query) {
                d3.selectAll('.node-bg')
                    .attr('stroke-width', 1)
                    .attr('opacity', 1);
                d3.selectAll('.node-label').attr('opacity', 1);
                return;
            }

            d3.selectAll('.node-bg')
                .attr('stroke-width', n => {
                    const text = `${n.username} ${n.summary}`.toLowerCase();
                    return text.includes(query) ? 2 : 1;
                })
                .attr('opacity', n => {
                    const text = `${n.username} ${n.summary}`.toLowerCase();
                    return text.includes(query) ? 1 : 0.3;
                });
            d3.selectAll('.node-label')
                .attr('opacity', n => {
                    const text = `${n.username} ${n.summary}`.toLowerCase();
                    return text.includes(query) ? 1 : 0.2;
                });
        });

        // Grok chat handling
        const grokChatForm = document.getElementById('grokChatForm');
        const grokChatHistory = document.getElementById('grokChatHistory');
        const grokPromptInput = document.getElementById('grokPrompt');
        const grokCountInput = document.getElementById('grokCount');
        const grokAllowedInput = document.getElementById('grokAllowed');
        const grokExcludedInput = document.getElementById('grokExcluded');
        const grokFromInput = document.getElementById('grokFromDate');
        const grokToInput = document.getElementById('grokToDate');
        const grokStatusEl = document.getElementById('grokStatus');
        const grokSendBtn = document.getElementById('grokSendBtn');

        function escapeHtml(str) {
            if (!str && str !== 0) return '';
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        function parseHandleInput(value) {
            if (!value) return null;
            const handles = value
                .split(',')
                .map(h => h.trim().replace(/^@/, ''))
                .filter(Boolean);
            return handles.length ? handles : null;
        }

        function appendGrokMessage(role, contentHtml) {
            if (!grokChatHistory) return;
            const hint = grokChatHistory.querySelector('.grok-chat-hint');
            if (hint) hint.remove();
            const message = document.createElement('div');
            message.className = `grok-chat-message ${role}`;
            message.innerHTML = contentHtml;
            grokChatHistory.appendChild(message);
            grokChatHistory.scrollTop = grokChatHistory.scrollHeight;
        }

        function renderGrokResponse(data) {
            const rows = Array.isArray(data?.rows) ? data.rows : [];
            if (rows.length > 0) {
                const intro = data.location
                    ? `${rows.length} posts mentioning "${escapeHtml(data.location)}"`
                    : `${rows.length} posts retrieved`;
                return `
                    <div class="grok-result">
                        <div class="grok-result-meta">${intro}</div>
                        ${rows.map(row => `
                            <div class="grok-row">
                                <div class="grok-row-header">
                                    <span>${escapeHtml(row.Date || row.date || '')}</span>
                                    <span>@${escapeHtml((row.Username || row.username || '').replace(/^@/, ''))}</span>
                                </div>
                                <p>${escapeHtml(row['Summary/Quote'] || row.summary || '')}</p>
                                ${row.Link ? `<a class="grok-row-link" href="${escapeHtml(row.Link)}" target="_blank" rel="noopener">Open post</a>` : ''}
                            </div>
                        `).join('')}
                    </div>
                `;
            }

            if (data.csv_text) {
                return `<pre class="grok-raw">${escapeHtml(data.csv_text)}</pre>`;
            }

            if (data.error) {
                return `<span class="grok-error">‚ö†Ô∏è ${escapeHtml(data.error)}</span>`;
            }

            return `<span>No data returned from Grok.</span>`;
        }

        function setGrokStatus(message, isError = false) {
            if (!grokStatusEl) return;
            grokStatusEl.textContent = message || '';
            grokStatusEl.style.color = isError ? '#ef4444' : '#8b949e';
        }

        if (grokChatForm) {
            grokChatForm.addEventListener('submit', async (event) => {
                event.preventDefault();
                const prompt = (grokPromptInput?.value || '').trim();
                if (!prompt) return;

                appendGrokMessage('user', escapeHtml(prompt));
                setGrokStatus('Contacting Grok for the latest X posts...');
                if (grokSendBtn) grokSendBtn.disabled = true;

                const payload = { prompt };
                const countValue = parseInt(grokCountInput?.value || '10', 10);
                payload.count = Number.isNaN(countValue) ? 10 : countValue;

                const allowed = parseHandleInput(grokAllowedInput?.value);
                if (allowed) payload.allowed_handles = allowed;
                const excluded = parseHandleInput(grokExcludedInput?.value);
                if (excluded) payload.excluded_handles = excluded;
                if (grokFromInput?.value) payload.from_date = grokFromInput.value;
                if (grokToInput?.value) payload.to_date = grokToInput.value;

                try {
                    const response = await fetch('/api/grok-search', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    const data = await response.json();
                    if (!response.ok) {
                        throw new Error(data.error || 'Grok search failed');
                    }
                    appendGrokMessage('assistant', renderGrokResponse(data));
                    setGrokStatus(`Completed via ${data.model || 'grok-4-1-fast'}.`);
                } catch (err) {
                    appendGrokMessage('assistant', `<span class="grok-error">‚ö†Ô∏è ${escapeHtml(err.message || String(err))}</span>`);
                    setGrokStatus(err.message || 'Unexpected error', true);
                } finally {
                    if (grokSendBtn) grokSendBtn.disabled = false;
                }
            });
        }

        // Export functionality
        document.getElementById('exportBtn').addEventListener('click', () => {
            const report = generateReport();
            downloadReport(report);
        });

        function generateReport() {
            let report = `# NYC Urban Ideas - Consolidated Report\n`;
            report += `Generated: ${new Date().toLocaleDateString()}\n\n`;
            report += `## Summary\n`;
            report += `- Total Ideas: ${graphData.nodes.length}\n`;
            report += `- Total Connections: ${graphData.edges.length}\n`;
            report += `- Identified Clusters: ${clusters.length}\n\n`;

            report += `## Actionable Clusters\n\n`;

            clusters.sort((a, b) => b.nodes.length - a.nodes.length).forEach(cluster => {
                report += `### ${cluster.name} (${cluster.nodes.length} supporters)\n\n`;
                report += `**Topic:** ${cluster.topic}\n\n`;
                report += `**Ideas:**\n`;
                cluster.nodes.forEach(node => {
                    report += `- @${node.username}: ${node.summary || 'No summary'}\n`;
                });
                report += `\n`;
            });

            report += `## All Ideas by Date\n\n`;
            graphData.nodes.sort((a, b) => new Date(b.date) - new Date(a.date)).forEach(node => {
                report += `- [${node.date}] @${node.username}: ${node.summary || 'No summary'}\n`;
            });

            return report;
        }

        function downloadReport(content) {
            const blob = new Blob([content], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `nyc-urban-ideas-report-${new Date().toISOString().split('T')[0]}.md`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Initialize
        loadData();
    </script>
</body>
</html>
